import Accessibility
import CoreGraphics
import DataDetection
import Dispatch
import Foundation
import UIKit.DocumentManager
import UIKit.NSAttributedString
import UIKit.NSDataAsset
import UIKit.NSDiffableDataSourceSectionSnapshot
import UIKit.NSFileProviderExtension
import UIKit.NSIndexPath_UIKitAdditions
import UIKit.NSItemProvider_UIKitAdditions
import UIKit.NSLayoutAnchor
import UIKit.NSLayoutConstraint
import UIKit.NSLayoutManager
import UIKit.NSParagraphStyle
import UIKit.NSShadow
import UIKit.NSStringDrawing
import UIKit.NSText
import UIKit.NSTextAttachment
import UIKit.NSTextContainer
import UIKit.NSTextContentManager
import UIKit.NSTextElement
import UIKit.NSTextLayoutFragment
import UIKit.NSTextLayoutManager
import UIKit.NSTextLineFragment
import UIKit.NSTextRange
import UIKit.NSTextSelection
import UIKit.NSTextSelectionNavigation
import UIKit.NSTextStorage
import UIKit.NSTextViewportLayoutController
import UIKit.NSToolbar_UIKitAdditions
import UIKit.NSTouchBar_UIKitAdditions
import UIKit.NSUserActivity_NSItemProvider
import UIKit.ShareSheet
import UIKit.UIAccelerometer
import UIKit.UIAccessibility
import UIKit.UIAccessibilityAdditions
import UIKit.UIAccessibilityConstants
import UIKit.UIAccessibilityContainer
import UIKit.UIAccessibilityContentSizeCategoryImageAdjusting
import UIKit.UIAccessibilityCustomAction
import UIKit.UIAccessibilityCustomRotor
import UIKit.UIAccessibilityElement
import UIKit.UIAccessibilityIdentification
import UIKit.UIAccessibilityLocationDescriptor
import UIKit.UIAccessibilityZoom
import UIKit.UIAction
import UIKit.UIActionSheet
import UIKit.UIActivity
import UIKit.UIActivityIndicatorView
import UIKit.UIActivityItemProvider
import UIKit.UIActivityItemsConfiguration
import UIKit.UIActivityItemsConfigurationReading
import UIKit.UIActivityViewController
import UIKit.UIAlert
import UIKit.UIAlertController
import UIKit.UIAlertView
import UIKit.UIAppearance
import UIKit.UIApplication
import UIKit.UIApplicationShortcutItem
import UIKit.UIAttachmentBehavior
import UIKit.UIBackgroundConfiguration
import UIKit.UIBandSelectionInteraction
import UIKit.UIBarAppearance
import UIKit.UIBarButtonItem
import UIKit.UIBarButtonItemAppearance
import UIKit.UIBarButtonItemGroup
import UIKit.UIBarCommon
import UIKit.UIBarItem
import UIKit.UIBehavioralStyle
import UIKit.UIBezierPath
import UIKit.UIBlurEffect
import UIKit.UIButton
import UIKit.UIButtonConfiguration
import UIKit.UICellAccessory
import UIKit.UICellConfigurationState
import UIKit.UICloudSharingController
import UIKit.UICollectionLayoutList
import UIKit.UICollectionView
import UIKit.UICollectionViewCell
import UIKit.UICollectionViewCompositionalLayout
import UIKit.UICollectionViewController
import UIKit.UICollectionViewFlowLayout
import UIKit.UICollectionViewItemRegistration
import UIKit.UICollectionViewLayout
import UIKit.UICollectionViewListCell
import UIKit.UICollectionViewTransitionLayout
import UIKit.UICollectionViewUpdateItem
import UIKit.UICollisionBehavior
import UIKit.UIColor
import UIKit.UIColorPickerViewController
import UIKit.UIColorWell
import UIKit.UICommand
import UIKit.UIConfigurationColorTransformer
import UIKit.UIConfigurationState
import UIKit.UIContentConfiguration
import UIKit.UIContentSizeCategory
import UIKit.UIContentSizeCategoryAdjusting
import UIKit.UIContextMenuConfiguration
import UIKit.UIContextMenuInteraction
import UIKit.UIContextualAction
import UIKit.UIControl
import UIKit.UIDataDetectors
import UIKit.UIDataSourceTranslating
import UIKit.UIDatePicker
import UIKit.UIDeferredMenuElement
import UIKit.UIDevice
import UIKit.UIDiffableDataSource
import UIKit.UIDocument
import UIKit.UIDocumentBrowserAction
import UIKit.UIDocumentBrowserViewController
import UIKit.UIDocumentInteractionController
import UIKit.UIDocumentMenuViewController
import UIKit.UIDocumentPickerExtensionViewController
import UIKit.UIDocumentPickerViewController
import UIKit.UIDragInteraction
import UIKit.UIDragItem
import UIKit.UIDragPreview
import UIKit.UIDragPreviewParameters
import UIKit.UIDragSession
import UIKit.UIDropInteraction
import UIKit.UIDynamicAnimator
import UIKit.UIDynamicBehavior
import UIKit.UIDynamicItemBehavior
import UIKit.UIEvent
import UIKit.UIEventAttribution
import UIKit.UIEventAttributionView
import UIKit.UIFeedbackGenerator
import UIKit.UIFieldBehavior
import UIKit.UIFocus
import UIKit.UIFocusAnimationCoordinator
import UIKit.UIFocusDebugger
import UIKit.UIFocusEffect
import UIKit.UIFocusGuide
import UIKit.UIFocusMovementHint
import UIKit.UIFocusSystem
import UIKit.UIFont
import UIKit.UIFontDescriptor
import UIKit.UIFontMetrics
import UIKit.UIFontPickerViewController
import UIKit.UIFontPickerViewControllerConfiguration
import UIKit.UIFoundation
import UIKit.UIGeometry
import UIKit.UIGestureRecognizer
import UIKit.UIGestureRecognizerSubclass
import UIKit.UIGraphics
import UIKit.UIGraphicsImageRenderer
import UIKit.UIGraphicsPDFRenderer
import UIKit.UIGraphicsRenderer
import UIKit.UIGraphicsRendererSubclass
import UIKit.UIGravityBehavior
import UIKit.UIGuidedAccess
import UIKit.UIGuidedAccessRestrictions
import UIKit.UIHoverGestureRecognizer
import UIKit.UIImage
import UIKit.UIImageAsset
import UIKit.UIImageConfiguration
import UIKit.UIImagePickerController
import UIKit.UIImageSymbolConfiguration
import UIKit.UIImageView
import UIKit.UIImpactFeedbackGenerator
import UIKit.UIIndirectScribbleInteraction
import UIKit.UIInputView
import UIKit.UIInputViewController
import UIKit.UIInteraction
import UIKit.UIInterface
import UIKit.UIKey
import UIKit.UIKeyCommand
import UIKit.UIKeyConstants
import UIKit.UIKeyboardLayoutGuide
import UIKit.UIKitCore
import UIKit.UIKitDefines
import UIKit.UILabel
import UIKit.UILargeContentViewer
import UIKit.UILayoutGuide
import UIKit.UILexicon
import UIKit.UIListContentConfiguration
import UIKit.UIListContentImageProperties
import UIKit.UIListContentTextProperties
import UIKit.UIListSeparatorConfiguration
import UIKit.UILocalNotification
import UIKit.UILocalizedIndexedCollation
import UIKit.UILongPressGestureRecognizer
import UIKit.UIManagedDocument
import UIKit.UIMenu
import UIKit.UIMenuBuilder
import UIKit.UIMenuController
import UIKit.UIMenuElement
import UIKit.UIMenuSystem
import UIKit.UIMotionEffect
import UIKit.UINavigationBar
import UIKit.UINavigationBarAppearance
import UIKit.UINavigationController
import UIKit.UINavigationItem
import UIKit.UINib
import UIKit.UINibDeclarations
import UIKit.UINibLoading
import UIKit.UINotificationFeedbackGenerator
import UIKit.UIOpenURLContext
import UIKit.UIPageControl
import UIKit.UIPageViewController
import UIKit.UIPanGestureRecognizer
import UIKit.UIPasteConfiguration
import UIKit.UIPasteConfigurationSupporting
import UIKit.UIPasteboard
import UIKit.UIPencilInteraction
import UIKit.UIPickerView
import UIKit.UIPinchGestureRecognizer
import UIKit.UIPointerAccessory
import UIKit.UIPointerInteraction
import UIKit.UIPointerLockState
import UIKit.UIPointerRegion
import UIKit.UIPointerStyle
import UIKit.UIPopoverBackgroundView
import UIKit.UIPopoverController
import UIKit.UIPopoverPresentationController
import UIKit.UIPopoverSupport
import UIKit.UIPresentationController
import UIKit.UIPress
import UIKit.UIPressesEvent
import UIKit.UIPreviewInteraction
import UIKit.UIPreviewParameters
import UIKit.UIPrintError
import UIKit.UIPrintFormatter
import UIKit.UIPrintInfo
import UIKit.UIPrintInteractionController
import UIKit.UIPrintPageRenderer
import UIKit.UIPrintPaper
import UIKit.UIPrintServiceExtension
import UIKit.UIPrinter
import UIKit.UIPrinterPickerController
import UIKit.UIProgressView
import UIKit.UIPushBehavior
import UIKit.UIReferenceLibraryViewController
import UIKit.UIRefreshControl
import UIKit.UIRegion
import UIKit.UIResponder
import UIKit.UIResponder_UIActivityItemsConfiguration
import UIKit.UIRotationGestureRecognizer
import UIKit.UIScene
import UIKit.UISceneActivationConditions
import UIKit.UISceneDefinitions
import UIKit.UISceneEnhancedStateRestoration
import UIKit.UISceneOptions
import UIKit.UISceneSession
import UIKit.UIScreen
import UIKit.UIScreenEdgePanGestureRecognizer
import UIKit.UIScreenMode
import UIKit.UIScreenshotService
import UIKit.UIScribbleInteraction
import UIKit.UIScrollView
import UIKit.UISearchBar
import UIKit.UISearchContainerViewController
import UIKit.UISearchController
import UIKit.UISearchDisplayController
import UIKit.UISearchSuggestion
import UIKit.UISearchTextField
import UIKit.UISegmentedControl
import UIKit.UISelectionFeedbackGenerator
import UIKit.UISheetPresentationController
import UIKit.UISlider
import UIKit.UISnapBehavior
import UIKit.UISplitViewController
import UIKit.UISpringLoadedInteraction
import UIKit.UISpringLoadedInteractionSupporting
import UIKit.UIStackView
import UIKit.UIStateRestoration
import UIKit.UIStatusBarManager
import UIKit.UIStepper
import UIKit.UIStoryboard
import UIKit.UIStoryboardPopoverSegue
import UIKit.UIStoryboardSegue
import UIKit.UIStringDrawing
import UIKit.UISwipeActionsConfiguration
import UIKit.UISwipeGestureRecognizer
import UIKit.UISwitch
import UIKit.UITabBar
import UIKit.UITabBarAppearance
import UIKit.UITabBarController
import UIKit.UITabBarItem
import UIKit.UITableView
import UIKit.UITableViewCell
import UIKit.UITableViewController
import UIKit.UITableViewHeaderFooterView
import UIKit.UITapGestureRecognizer
import UIKit.UITargetedDragPreview
import UIKit.UITargetedPreview
import UIKit.UITextChecker
import UIKit.UITextDragPreviewRenderer
import UIKit.UITextDragURLPreviews
import UIKit.UITextDragging
import UIKit.UITextDropProposal
import UIKit.UITextDropping
import UIKit.UITextField
import UIKit.UITextFormattingCoordinator
import UIKit.UITextInput
import UIKit.UITextInputTraits
import UIKit.UITextInteraction
import UIKit.UITextItemInteraction
import UIKit.UITextPasteConfigurationSupporting
import UIKit.UITextPasteDelegate
import UIKit.UITextView
import UIKit.UITimingCurveProvider
import UIKit.UITimingParameters
import UIKit.UIToolTipInteraction
import UIKit.UIToolbar
import UIKit.UIToolbarAppearance
import UIKit.UITouch
import UIKit.UITrackingLayoutGuide
import UIKit.UITraitCollection
import UIKit.UIUserActivity
import UIKit.UIUserNotificationSettings
import UIKit.UIVibrancyEffect
import UIKit.UIVideoEditorController
import UIKit.UIView
import UIKit.UIViewAnimating
import UIKit.UIViewConfigurationState
import UIKit.UIViewController
import UIKit.UIViewControllerTransitionCoordinator
import UIKit.UIViewControllerTransitioning
import UIKit.UIViewPropertyAnimator
import UIKit.UIVisualEffect
import UIKit.UIVisualEffectView
import UIKit.UIWebView
import UIKit.UIWindow
import UIKit.UIWindowScene
import UIKit.UIWindowSceneActivationAction
import UIKit.UIWindowSceneActivationConfiguration
import UIKit.UIWindowSceneActivationInteraction
import UIKit.UIWindowSceneActivationRequestOptions
import UIKit.UNNotificationResponse_UIKitAdditions
import _Concurrency

@available(iOS 14.0, tvOS 14.0, *)
public struct NSDiffableDataSourceSectionSnapshot<ItemIdentifierType> where ItemIdentifierType : Hashable {

    public init()

    public init(_ snapshot: NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>)

    public mutating func append(_ items: [ItemIdentifierType], to parent: ItemIdentifierType? = nil)

    public mutating func insert(_ items: [ItemIdentifierType], before item: ItemIdentifierType)

    public mutating func insert(_ items: [ItemIdentifierType], after item: ItemIdentifierType)

    public mutating func delete(_ items: [ItemIdentifierType])

    public mutating func deleteAll()

    public mutating func expand(_ items: [ItemIdentifierType])

    public mutating func collapse(_ items: [ItemIdentifierType])

    public mutating func replace(childrenOf parent: ItemIdentifierType, using snapshot: NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>)

    public mutating func insert(_ snapshot: NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>, before item: (ItemIdentifierType))

    public mutating func insert(_ snapshot: NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>, after item: (ItemIdentifierType))

    public func isExpanded(_ item: ItemIdentifierType) -> Bool

    public func isVisible(_ item: ItemIdentifierType) -> Bool

    public func contains(_ item: ItemIdentifierType) -> Bool

    public func level(of item: ItemIdentifierType) -> Int

    public func index(of item: ItemIdentifierType) -> Int?

    public func parent(of child: ItemIdentifierType) -> ItemIdentifierType?

    public func snapshot(of parent: ItemIdentifierType, includingParent: Bool = false) -> NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>

    public var items: [ItemIdentifierType] { get }

    public var rootItems: [ItemIdentifierType] { get }

    public var visibleItems: [ItemIdentifierType] { get }

    public func visualDescription() -> String
}

@available(iOS 14.0, tvOS 14.0, *)
public struct NSDiffableDataSourceSectionTransaction<SectionIdentifierType, ItemIdentifierType> where SectionIdentifierType : Hashable, ItemIdentifierType : Hashable {

    public var sectionIdentifier: SectionIdentifierType { get }

    public var initialSnapshot: NSDiffableDataSourceSectionSnapshot<ItemIdentifierType> { get }

    public var finalSnapshot: NSDiffableDataSourceSectionSnapshot<ItemIdentifierType> { get }

    public var difference: CollectionDifference<ItemIdentifierType> { get }
}

@available(iOS 13.0, tvOS 13.0, *)
public struct NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType> where SectionIdentifierType : Hashable, ItemIdentifierType : Hashable {

    public init()

    public var numberOfItems: Int { get }

    public var numberOfSections: Int { get }

    public var sectionIdentifiers: [SectionIdentifierType] { get }

    public var itemIdentifiers: [ItemIdentifierType] { get }

    @available(iOS 15.0, tvOS 15.0, *)
    public var reloadedSectionIdentifiers: [SectionIdentifierType] { get }

    @available(iOS 15.0, tvOS 15.0, *)
    public var reloadedItemIdentifiers: [ItemIdentifierType] { get }

    @available(iOS 15.0, tvOS 15.0, *)
    public var reconfiguredItemIdentifiers: [ItemIdentifierType] { get }

    public func numberOfItems(inSection identifier: SectionIdentifierType) -> Int

    public func itemIdentifiers(inSection identifier: SectionIdentifierType) -> [ItemIdentifierType]

    public func sectionIdentifier(containingItem identifier: ItemIdentifierType) -> SectionIdentifierType?

    public func indexOfItem(_ identifier: ItemIdentifierType) -> Int?

    public func indexOfSection(_ identifier: SectionIdentifierType) -> Int?

    public mutating func appendItems(_ identifiers: [ItemIdentifierType], toSection sectionIdentifier: SectionIdentifierType? = nil)

    public mutating func insertItems(_ identifiers: [ItemIdentifierType], beforeItem beforeIdentifier: ItemIdentifierType)

    public mutating func insertItems(_ identifiers: [ItemIdentifierType], afterItem afterIdentifier: ItemIdentifierType)

    public mutating func deleteItems(_ identifiers: [ItemIdentifierType])

    public mutating func deleteAllItems()

    public mutating func moveItem(_ identifier: ItemIdentifierType, beforeItem toIdentifier: ItemIdentifierType)

    public mutating func moveItem(_ identifier: ItemIdentifierType, afterItem toIdentifier: ItemIdentifierType)

    public mutating func reloadItems(_ identifiers: [ItemIdentifierType])

    @available(iOS 15.0, tvOS 15.0, *)
    public mutating func reconfigureItems(_ identifiers: [ItemIdentifierType])

    public mutating func appendSections(_ identifiers: [SectionIdentifierType])

    public mutating func insertSections(_ identifiers: [SectionIdentifierType], beforeSection toIdentifier: SectionIdentifierType)

    public mutating func insertSections(_ identifiers: [SectionIdentifierType], afterSection toIdentifier: SectionIdentifierType)

    public mutating func deleteSections(_ identifiers: [SectionIdentifierType])

    public mutating func moveSection(_ identifier: SectionIdentifierType, beforeSection toIdentifier: SectionIdentifierType)

    public mutating func moveSection(_ identifier: SectionIdentifierType, afterSection toIdentifier: SectionIdentifierType)

    public mutating func reloadSections(_ identifiers: [SectionIdentifierType])
}

@available(iOS 14.0, tvOS 14.0, *)
public struct NSDiffableDataSourceTransaction<SectionIdentifierType, ItemIdentifierType> where SectionIdentifierType : Hashable, ItemIdentifierType : Hashable {

    public var initialSnapshot: NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType> { get }

    public var finalSnapshot: NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType> { get }

    public var difference: CollectionDifference<ItemIdentifierType> { get }

    public var sectionTransactions: [NSDiffableDataSourceSectionTransaction<SectionIdentifierType, ItemIdentifierType>] { get }
}

@available(swift, deprecated: 4.2, message: "Use the overload of UIApplicationMain where the type of the second parameter is UnsafeMutablePointer<UnsafeMutablePointer<Int8>?>, which is the same as the type of CommandLine.unsafeArgv.")
public func UIApplicationMain(_ argc: Int32, _ argv: UnsafeMutablePointer<UnsafeMutablePointer<Int8>>!, _ principalClassName: String?, _ delegateClassName: String?) -> Int32

@available(iOS 14.0, tvOS 14.0, *)
public struct UIBackgroundConfiguration : Hashable {

    /// Returns a clear configuration, with no default styling.
    public static func clear() -> UIBackgroundConfiguration

    /// Returns the default configuration for a plain list cell.
    public static func listPlainCell() -> UIBackgroundConfiguration

    /// Returns the default configuration for a plain list header or footer.
    public static func listPlainHeaderFooter() -> UIBackgroundConfiguration

    /// Returns the default configuration for a grouped list cell.
    public static func listGroupedCell() -> UIBackgroundConfiguration

    /// Returns the default configuration for a grouped list header or footer.
    public static func listGroupedHeaderFooter() -> UIBackgroundConfiguration

    /// Returns the default configuration for a sidebar list header.
    public static func listSidebarHeader() -> UIBackgroundConfiguration

    /// Returns the default configuration for a sidebar list cell.
    public static func listSidebarCell() -> UIBackgroundConfiguration

    /// Returns the default configuration for an accompanied sidebar list cell.
    public static func listAccompaniedSidebarCell() -> UIBackgroundConfiguration

    /// Returns the configuration updated for the specified state, by applying the configuration's default values for that state to any properties that have not been customized.
    public func updated(for state: UIConfigurationState) -> UIBackgroundConfiguration

    /// A custom view for the background. The custom view must have translatesAutoresizingMaskIntoConstraints
    /// enabled, but may use auto layout constraints internally for layout of subviews.
    public var customView: UIView?

    /// The preferred corner radius (using a continuous corner curve) for the background and stroke. Does not apply to any custom view. Default is 0.
    /// If the view is too small to fit the requested radius, the corner curve and radius will be adjusted to fit.
    public var cornerRadius: CGFloat

    /// Insets (or outsets, if negative) for the background and stroke, relative to the edges of the containing view. These also apply to the custom view. Default is NSDirectionalEdgeInsetsZero.
    public var backgroundInsets: NSDirectionalEdgeInsets

    /// The edges on which the containing view's layout margins are added to the `backgroundInsets`, effectively making the `backgroundInsets` values relative
    /// to the containing view's layout margins for these edges. Default is NSDirectionalRectEdgeNone.
    public var edgesAddingLayoutMarginsToBackgroundInsets: NSDirectionalRectEdge

    /// Configures the color of the background. A nil value uses the view's tint color; use `.clear` for no color (transparent).
    public var backgroundColor: UIColor?

    /// Optional color transformer that is used to resolve the background color. A nil value means the `backgroundColor` is used as-is.
    public var backgroundColorTransformer: UIConfigurationColorTransformer?

    /// Returns the resolved background color for the specified tint color, based on the `backgroundColor` and `backgroundColorTransformer`.
    public func resolvedBackgroundColor(for tintColor: UIColor) -> UIColor

    /// The visual effect to apply to the background. Default is nil.
    public var visualEffect: UIVisualEffect?

    /// The image to use. Default is nil.
    @available(iOS 15.0, tvOS 15.0, *)
    public var image: UIImage?

    /// The content mode to use when rendering the image. Default is .scaleToFill.
    @available(iOS 15.0, tvOS 15.0, *)
    public var imageContentMode: UIView.ContentMode

    /// Configures the color of the stroke. A nil value uses the view's tint color; use `.clear` for no color (transparent).
    public var strokeColor: UIColor?

    /// Optional color transformer that is used to resolve the stroke color. A nil value means the `strokeColor` is used as-is.
    public var strokeColorTransformer: UIConfigurationColorTransformer?

    /// Returns the resolved stroke color for the specified tint color, based on the `strokeColor` and `strokeColorTransformer`.
    public func resolvedStrokeColor(for tintColor: UIColor) -> UIColor

    /// The width of the stroke. Default is 0.
    public var strokeWidth: CGFloat

    /// Outset (or inset, if negative) for the stroke, relative to the background (including any backgroundInsets). Default is 0.
    /// The corner radius of the stroke is adjusted for any outset to remain concentric with the background.
    public var strokeOutset: CGFloat

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: UIBackgroundConfiguration, b: UIBackgroundConfiguration) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }
}

@available(iOS 14.0, tvOS 14.0, *)
extension UIBackgroundConfiguration : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@available(iOS 14.0, tvOS 14.0, *)
public struct UICellAccessory {

    public typealias ActionHandler = () -> Void

    /// The states an accessory is displayed for.
    public enum DisplayedState {

        /// The accessory is always displayed.
        case always

        /// The accessory is displayed only when the cell is editing.
        case whenEditing

        /// The accessory is displayed only when the cell is not editing.
        case whenNotEditing

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: UICellAccessory.DisplayedState, b: UICellAccessory.DisplayedState) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }
    }

    /// The layout dimension used for an accessory.
    public enum LayoutDimension {

        /// The actual dimension of the accessory is used.
        case actual

        /// The system standard layout dimension for accessories is used.
        case standard

        /// The specified custom value is used for the dimension.
        case custom(CGFloat)
    }

    public struct DisclosureIndicatorOptions {

        /// Hidden accessories take up space in the layout, but are not visible and do not provide any behaviors.
        /// Use this property to achieve a consistent layout across cells when some show the accessory and others do not.
        public var isHidden: Bool

        /// The layout width that is reserved for the accessory, inside which the accessory will be centered.
        public var reservedLayoutWidth: UICellAccessory.LayoutDimension

        /// The tint color to apply to the accessory. Default value is nil, which uses the system default.
        public var tintColor: UIColor?

        public init(isHidden: Bool? = nil, reservedLayoutWidth: UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil)
    }

    /// A disclosure chevron that points in the trailing direction. Placed on the trailing edge.
    public static func disclosureIndicator(displayed: UICellAccessory.DisplayedState = .always, options: UICellAccessory.DisclosureIndicatorOptions = DisclosureIndicatorOptions()) -> UICellAccessory

    public struct CheckmarkOptions {

        /// Hidden accessories take up space in the layout, but are not visible and do not provide any behaviors.
        /// Use this property to achieve a consistent layout across cells when some show the accessory and others do not.
        public var isHidden: Bool

        /// The layout width that is reserved for the accessory, inside which the accessory will be centered.
        public var reservedLayoutWidth: UICellAccessory.LayoutDimension

        /// The tint color to apply to the accessory. Default value is nil, which uses the system default.
        public var tintColor: UIColor?

        public init(isHidden: Bool? = nil, reservedLayoutWidth: UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil)
    }

    /// A checkmark with default green color. Placed on the trailing edge.
    public static func checkmark(displayed: UICellAccessory.DisplayedState = .always, options: UICellAccessory.CheckmarkOptions = CheckmarkOptions()) -> UICellAccessory

    public struct DeleteOptions {

        /// Hidden accessories take up space in the layout, but are not visible and do not provide any behaviors.
        /// Use this property to achieve a consistent layout across cells when some show the accessory and others do not.
        public var isHidden: Bool

        /// The layout width that is reserved for the accessory, inside which the accessory will be centered.
        public var reservedLayoutWidth: UICellAccessory.LayoutDimension

        /// The tint color to apply to the accessory. Default value is nil, which uses the system default.
        public var tintColor: UIColor?

        /// The background color to apply to the accessory. Default value is nil, which uses the system default.
        public var backgroundColor: UIColor?

        public init(isHidden: Bool? = nil, reservedLayoutWidth: UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil, backgroundColor: UIColor? = nil)
    }

    /// A delete control (minus sign inside a circle) with default red color. Placed on the leading edge.
    public static func delete(displayed: UICellAccessory.DisplayedState = .whenEditing, options: UICellAccessory.DeleteOptions = DeleteOptions(), actionHandler: UICellAccessory.ActionHandler? = nil) -> UICellAccessory

    public struct InsertOptions {

        /// Hidden accessories take up space in the layout, but are not visible and do not provide any behaviors.
        /// Use this property to achieve a consistent layout across cells when some show the accessory and others do not.
        public var isHidden: Bool

        /// The layout width that is reserved for the accessory, inside which the accessory will be centered.
        public var reservedLayoutWidth: UICellAccessory.LayoutDimension

        /// The tint color to apply to the accessory. Default value is nil, which uses the system default.
        public var tintColor: UIColor?

        /// The background color to apply to the accessory. Default value is nil, which uses the system default.
        public var backgroundColor: UIColor?

        public init(isHidden: Bool? = nil, reservedLayoutWidth: UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil, backgroundColor: UIColor? = nil)
    }

    /// An insert control (plus sign inside a circle) with default green color. Placed on the leading edge.
    public static func insert(displayed: UICellAccessory.DisplayedState = .whenEditing, options: UICellAccessory.InsertOptions = InsertOptions(), actionHandler: UICellAccessory.ActionHandler? = nil) -> UICellAccessory

    public struct ReorderOptions {

        /// Hidden accessories take up space in the layout, but are not visible and do not provide any behaviors.
        /// Use this property to achieve a consistent layout across cells when some show the accessory and others do not.
        public var isHidden: Bool

        /// The layout width that is reserved for the accessory, inside which the accessory will be centered.
        public var reservedLayoutWidth: UICellAccessory.LayoutDimension

        /// The tint color to apply to the accessory. Default value is nil, which uses the system default.
        public var tintColor: UIColor?

        /// Whether a vertical separator is displayed before the accessory when it is placed after another
        /// accessory. Default is true.
        public var showsVerticalSeparator: Bool

        public init(isHidden: Bool? = nil, reservedLayoutWidth: UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil, showsVerticalSeparator: Bool? = nil)
    }

    /// A reorder control (three horizontal lines) with default gray color that automatically initiates interactive
    /// reordering on the collection view when dragged (if supported). Placed on the trailing edge.
    public static func reorder(displayed: UICellAccessory.DisplayedState = .whenEditing, options: UICellAccessory.ReorderOptions = ReorderOptions()) -> UICellAccessory

    public struct MultiselectOptions {

        /// Hidden accessories take up space in the layout, but are not visible and do not provide any behaviors.
        /// Use this property to achieve a consistent layout across cells when some show the accessory and others do not.
        public var isHidden: Bool

        /// The layout width that is reserved for the accessory, inside which the accessory will be centered.
        public var reservedLayoutWidth: UICellAccessory.LayoutDimension

        /// The tint color to apply to the accessory. Default value is nil, which uses the system default.
        public var tintColor: UIColor?

        /// The background color to apply to the accessory. Default value is nil, which uses the system default.
        public var backgroundColor: UIColor?

        public init(isHidden: Bool? = nil, reservedLayoutWidth: UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil, backgroundColor: UIColor? = nil)
    }

    /// A two-state control whose appearance follows the selection state of the cell (empty circle when deselected,
    /// filled circle with checkmark when selected). Placed on the leading edge.
    public static func multiselect(displayed: UICellAccessory.DisplayedState = .whenEditing, options: UICellAccessory.MultiselectOptions = MultiselectOptions()) -> UICellAccessory

    public struct OutlineDisclosureOptions {

        public enum Style {

            /// The style will be automatically determined based on whether the cell is configured
            /// to be a section header or not.
            case automatic

            /// A style appropriate for a section header, where a tap anywhere in the header will
            /// toggle the expansion state of the item (the cell cannot be selected).
            case header

            /// A style appropriate for a cell which can be selected itself and also has nested children,
            /// where only taps on the outline disclosure will toggle the expansion state of the item;
            /// taps on the cell will select the item as normal.
            case cell

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: UICellAccessory.OutlineDisclosureOptions.Style, b: UICellAccessory.OutlineDisclosureOptions.Style) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
            ///   compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            public var hashValue: Int { get }
        }

        /// The style of the outline disclosure accessory. Default is automatic.
        public var style: UICellAccessory.OutlineDisclosureOptions.Style

        /// Hidden accessories take up space in the layout, but are not visible and do not provide any behaviors.
        /// Use this property to achieve a consistent layout across cells when some show the accessory and others do not.
        public var isHidden: Bool

        /// The layout width that is reserved for the accessory, inside which the accessory will be centered.
        public var reservedLayoutWidth: UICellAccessory.LayoutDimension

        /// The tint color to apply to the accessory. Default value is nil, which uses the system default.
        public var tintColor: UIColor?

        public init(style: UICellAccessory.OutlineDisclosureOptions.Style? = nil, isHidden: Bool? = nil, reservedLayoutWidth: UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil)
    }

    /// A rotating disclosure chevron for use with outlines, used to indicate and toggle the expanded/collapsed
    /// state of the item. Placed on the trailing edge on iOS and iPadOS. On Catalyst, placed on the trailing
    /// edge of headers, but the leading edge of cells.
    public static func outlineDisclosure(displayed: UICellAccessory.DisplayedState = .always, options: UICellAccessory.OutlineDisclosureOptions = OutlineDisclosureOptions(), actionHandler: UICellAccessory.ActionHandler? = nil) -> UICellAccessory

    public struct LabelOptions {

        /// Hidden accessories take up space in the layout, but are not visible and do not provide any behaviors.
        /// Use this property to achieve a consistent layout across cells when some show the accessory and others do not.
        public var isHidden: Bool

        /// The layout width that is reserved for the accessory, inside which the accessory will be centered.
        public var reservedLayoutWidth: UICellAccessory.LayoutDimension

        /// The tint color to apply to the accessory. Default value is nil, which uses the system default.
        public var tintColor: UIColor?

        /// The font used for the label. Default is the preferred font for UIFontTextStyleBody.
        public var font: UIFont

        /// Whether the label automatically adjusts its font based on the content size category. Default is true.
        public var adjustsFontForContentSizeCategory: Bool

        public init(isHidden: Bool? = nil, reservedLayoutWidth: UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil, font: UIFont? = nil, adjustsFontForContentSizeCategory: Bool? = nil)
    }

    /// A label displaying a short string of text, typically a small number such as a count for the associated
    /// item. Placed on the trailing edge.
    public static func label(text: String, displayed: UICellAccessory.DisplayedState = .always, options: UICellAccessory.LabelOptions = LabelOptions()) -> UICellAccessory

    /// Specifies the edge, displayed states, and position for an accessory.
    public enum Placement {

        /// Return an index to insert the accessory at, given an array of the existing accessories
        /// on the edge (in leading to trailing order).
        public typealias Position = (_ accessories: [UICellAccessory]) -> Int

        /// Positions the accessory before the accessory matching the type specified, or at the beginning if not found.
        public static func position(before accessory: UICellAccessory) -> UICellAccessory.Placement.Position

        /// Positions the accessory after the accessory matching the type specified, or at the end if not found.
        public static func position(after accessory: UICellAccessory) -> UICellAccessory.Placement.Position

        /// Accessory placed on the leading edge, by default displayed for both states, and inserted at a
        /// position closest to the cell content.
        case leading(displayed: UICellAccessory.DisplayedState = .always, at: UICellAccessory.Placement.Position = { $0.count })

        /// Accessory placed on the trailing edge, by default displayed for both states, and inserted at a
        /// position closest to the cell content.
        case trailing(displayed: UICellAccessory.DisplayedState = .always, at: UICellAccessory.Placement.Position = { _ in 0 })
    }

    public struct CustomViewConfiguration {

        /// The custom view to display.
        public let customView: UIView

        /// The placement for the accessory.
        public let placement: UICellAccessory.Placement

        /// Hidden accessories take up space in the layout, but are not visible and do not provide any behaviors.
        /// Use this property to achieve a consistent layout across cells when some show the accessory and others do not.
        public var isHidden: Bool

        /// The layout width that is reserved for the accessory, inside which the accessory will be centered.
        public var reservedLayoutWidth: UICellAccessory.LayoutDimension

        /// The tint color to apply to the accessory. Default value is nil, which uses the system default.
        public var tintColor: UIColor?

        /// Whether the current frame size of the view is preserved (true), or whether it is sized during
        /// layout of accessories (false). Default is false.
        public var maintainsFixedSize: Bool

        public init(customView: UIView, placement: UICellAccessory.Placement, isHidden: Bool? = nil, reservedLayoutWidth: UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil, maintainsFixedSize: Bool? = nil)
    }

    /// An accessory using a custom view.
    public static func customView(configuration: UICellAccessory.CustomViewConfiguration) -> UICellAccessory

    public enum AccessoryType : Hashable {

        case disclosureIndicator

        case outlineDisclosure

        case checkmark

        case delete

        case insert

        case reorder

        case multiselect

        case label

        case customView(UIView)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (lhs: UICellAccessory.AccessoryType, rhs: UICellAccessory.AccessoryType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }
    }

    public let accessoryType: UICellAccessory.AccessoryType
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICellAccessory.DisplayedState : Equatable {
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICellAccessory.DisplayedState : Hashable {
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICellAccessory.OutlineDisclosureOptions.Style : Equatable {
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICellAccessory.OutlineDisclosureOptions.Style : Hashable {
}

@available(iOS 14.0, tvOS 14.0, *)
public struct UICellConfigurationState : UIConfigurationState, Hashable {

    @available(iOS 14.0, *)
    public enum DragState : Hashable {

        /// The cell is not associated with a drag session.
        case none

        /// The cell is being lifted, before has joined a drag session.
        case lifting

        /// The cell is part of an active drag session.
        case dragging

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: UICellConfigurationState.DragState, b: UICellConfigurationState.DragState) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }
    }

    @available(iOS 14.0, *)
    public enum DropState : Hashable {

        /// The cell is not associated with a drag session.
        case none

        /// A drag session is active and may perform a drop in the cell's container, but the cell itself
        /// is not the drop target.
        case notTargeted

        /// The cell is the drop target for a drag session.
        case targeted

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: UICellConfigurationState.DropState, b: UICellConfigurationState.DropState) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }
    }

    public var traitCollection: UITraitCollection

    public var isDisabled: Bool

    public var isHighlighted: Bool

    public var isSelected: Bool

    public var isFocused: Bool

    @available(iOS 15.0, tvOS 15.0, *)
    public var isPinned: Bool

    public var isEditing: Bool

    public var isExpanded: Bool

    public var isSwiped: Bool

    public var isReordering: Bool

    public var cellDragState: UICellConfigurationState.DragState

    public var cellDropState: UICellConfigurationState.DropState

    /// Access custom states by key.
    public subscript(key: UIConfigurationStateCustomKey) -> AnyHashable?

    /// Returns a new instance with the specified trait collection.
    public init(traitCollection: UITraitCollection)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: UICellConfigurationState, rhs: UICellConfigurationState) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICellConfigurationState : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@available(iOS 14.0, tvOS 14.0, *)
public struct UICollectionLayoutListConfiguration {

    public enum Appearance {

        case plain

        case grouped

        @available(tvOS, unavailable)
        case insetGrouped

        @available(tvOS, unavailable)
        case sidebar

        @available(tvOS, unavailable)
        case sidebarPlain

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: UICollectionLayoutListConfiguration.Appearance, b: UICollectionLayoutListConfiguration.Appearance) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }
    }

    public enum HeaderMode {

        case none

        case supplementary

        case firstItemInSection

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: UICollectionLayoutListConfiguration.HeaderMode, b: UICollectionLayoutListConfiguration.HeaderMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }
    }

    public enum FooterMode {

        case none

        case supplementary

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: UICollectionLayoutListConfiguration.FooterMode, b: UICollectionLayoutListConfiguration.FooterMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }
    }

    @available(tvOS, unavailable)
    public typealias SwipeActionsConfigurationProvider = (_ indexPath: IndexPath) -> UISwipeActionsConfiguration?

    /// A closure that is executed by list sections to provide granular control over separator appearance.
    /// 
    /// - Parameter itemIndexPath: The `IndexPath` of the item for which separators are being configured.
    /// - Parameter sectionSeparatorConfiguration: The list section's separator configuration for this cell. This configuration contains
    /// the values for separator visibility and insets according to the current state of the item.
    ///
    /// - Returns: The configuration to use for separators at `itemIndexPath`.
    @available(iOS 14.5, *)
    @available(tvOS, unavailable)
    public typealias ItemSeparatorHandler = (_ itemIndexPath: IndexPath, _ sectionSeparatorConfiguration: UIListSeparatorConfiguration) -> UIListSeparatorConfiguration

    public init(appearance: UICollectionLayoutListConfiguration.Appearance)

    public var appearance: UICollectionLayoutListConfiguration.Appearance { get }

    /// Whether this section shows separators or not. For additional control, see separatorConfiguration
    /// Note that when this property is NO, the separatorConfiguration is ineffective.
    @available(tvOS, unavailable)
    public var showsSeparators: Bool

    /// The section's preferred configuration for separators. This configuration only takes effect if showsSeparators is YES.
    /// For more more granular control over separator appearance, use `itemSeparatorHandler`.
    @available(iOS 14.5, *)
    @available(tvOS, unavailable)
    public var separatorConfiguration: UIListSeparatorConfiguration

    /// The configuration returned from this block will be treated as the final separator configuration
    /// for the item at the passed in `IndexPath`.
    @available(iOS 14.5, *)
    @available(tvOS, unavailable)
    public var itemSeparatorHandler: UICollectionLayoutListConfiguration.ItemSeparatorHandler?

    public var backgroundColor: UIColor?

    @available(tvOS, unavailable)
    public var leadingSwipeActionsConfigurationProvider: UICollectionLayoutListConfiguration.SwipeActionsConfigurationProvider?

    @available(tvOS, unavailable)
    public var trailingSwipeActionsConfigurationProvider: UICollectionLayoutListConfiguration.SwipeActionsConfigurationProvider?

    public var headerMode: UICollectionLayoutListConfiguration.HeaderMode

    public var footerMode: UICollectionLayoutListConfiguration.FooterMode

    /// Padding above each section header. The default value is nil (automatic).
    @available(iOS 15.0, tvOS 15.0, *)
    public var headerTopPadding: CGFloat?
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionLayoutListConfiguration.Appearance : Equatable {
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionLayoutListConfiguration.Appearance : Hashable {
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionLayoutListConfiguration.HeaderMode : Equatable {
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionLayoutListConfiguration.HeaderMode : Hashable {
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionLayoutListConfiguration.FooterMode : Equatable {
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionLayoutListConfiguration.FooterMode : Hashable {
}

@available(iOS 13.0, tvOS 13.0, *)
open class UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType> : NSObject, UICollectionViewDataSource where SectionIdentifierType : Hashable, ItemIdentifierType : Hashable {

    public typealias CellProvider = (_ collectionView: UICollectionView, _ indexPath: IndexPath, _ itemIdentifier: ItemIdentifierType) -> UICollectionViewCell?

    public typealias SupplementaryViewProvider = (_ collectionView: UICollectionView, _ elementKind: String, _ indexPath: IndexPath) -> UICollectionReusableView?

    public var supplementaryViewProvider: UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.SupplementaryViewProvider?

    public init(collectionView: UICollectionView, cellProvider: @escaping UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.CellProvider)

    nonisolated open func apply(_ snapshot: NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, animatingDifferences: Bool = true, completion: (() -> Void)? = nil)

    @available(iOS 15.0, tvOS 15.0, *)
    nonisolated open func apply(_ snapshot: NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, animatingDifferences: Bool = true) async

    @available(iOS 15.0, tvOS 15.0, *)
    nonisolated open func applySnapshotUsingReloadData(_ snapshot: NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, completion: (() -> Void)? = nil)

    @available(iOS 15.0, tvOS 15.0, *)
    nonisolated open func applySnapshotUsingReloadData(_ snapshot: NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>) async

    nonisolated open func snapshot() -> NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>

    @available(iOS 15.0, tvOS 15.0, *)
    open func sectionIdentifier(for index: Int) -> SectionIdentifierType?

    @available(iOS 15.0, tvOS 15.0, *)
    open func index(for sectionIdentifier: SectionIdentifierType) -> Int?

    open func itemIdentifier(for indexPath: IndexPath) -> ItemIdentifierType?

    open func indexPath(for itemIdentifier: ItemIdentifierType) -> IndexPath?

    @objc open func numberOfSections(in collectionView: UICollectionView) -> Int

    @objc open func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int

    @objc open func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell

    @objc open func collectionView(_ collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, at indexPath: IndexPath) -> UICollectionReusableView

    @objc open func collectionView(_ collectionView: UICollectionView, canMoveItemAt indexPath: IndexPath) -> Bool

    @objc open func collectionView(_ collectionView: UICollectionView, moveItemAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath)

    @objc open func indexTitles(for collectionView: UICollectionView) -> [String]?

    @objc open func collectionView(_ collectionView: UICollectionView, indexPathForIndexTitle title: String, at index: Int) -> IndexPath

    public func description() -> String
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewDiffableDataSource {

    nonisolated public func apply(_ snapshot: NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>, to section: SectionIdentifierType, animatingDifferences: Bool = true, completion: (() -> Void)? = nil)

    @available(iOS 15.0, tvOS 15.0, *)
    nonisolated public func apply(_ snapshot: NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>, to section: SectionIdentifierType, animatingDifferences: Bool = true) async

    nonisolated public func snapshot(for section: SectionIdentifierType) -> NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewDiffableDataSource {

    public struct ReorderingHandlers {

        public var canReorderItem: ((ItemIdentifierType) -> Bool)?

        public var willReorder: ((NSDiffableDataSourceTransaction<SectionIdentifierType, ItemIdentifierType>) -> Void)?

        public var didReorder: ((NSDiffableDataSourceTransaction<SectionIdentifierType, ItemIdentifierType>) -> Void)?

        public init()
    }

    public var reorderingHandlers: UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.ReorderingHandlers
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewDiffableDataSource {

    public struct SectionSnapshotHandlers<ItemIdentifierType> where ItemIdentifierType : Hashable {

        public var shouldExpandItem: ((ItemIdentifierType) -> Bool)?

        public var willExpandItem: ((ItemIdentifierType) -> Void)?

        public var shouldCollapseItem: ((ItemIdentifierType) -> Bool)?

        public var willCollapseItem: ((ItemIdentifierType) -> Void)?

        public var snapshotForExpandingParent: ((ItemIdentifierType, NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>) -> NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>)?

        public init()
    }

    public var sectionSnapshotHandlers: UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.SectionSnapshotHandlers<ItemIdentifierType>
}

@available(iOS 14.0, tvOS 14.0, *)
public struct UIConfigurationColorTransformer {

    public let transform: (UIColor) -> UIColor

    public init(_ transform: @escaping (UIColor) -> UIColor)

    public func callAsFunction(_ input: UIColor) -> UIColor

    /// A color transformer that returns a grayscale version of the color.
    public static let grayscale: UIConfigurationColorTransformer

    /// A color transformer that either passes the original color through, or replaces it with the system accent color.
    /// - When the system accent color is set to Multicolor: Returns the original color.
    /// - When the system accent color is configured to any other color:  Returns that color.
    /// - On platforms without a system accent color: Returns the original color.
    public static let preferredTint: UIConfigurationColorTransformer

    /// A color transformer that gives the color a monochrome tint. Use this to deemphasize the tinted item.
    /// It remains monochrome regardless of the system accent color (if the platform has one).
    public static let monochromeTint: UIConfigurationColorTransformer
}

@available(iOS 14.0, tvOS 14.0, *)
public protocol UIConfigurationState {

    /// Returns a new instance with the specified trait collection.
    init(traitCollection: UITraitCollection)

    var traitCollection: UITraitCollection { get set }

    /// Access custom states by key.
    subscript(key: UIConfigurationStateCustomKey) -> AnyHashable? { get set }
}

@available(iOS 15.0, tvOS 15.0, *)
public struct UIConfigurationTextAttributesTransformer {

    public let transform: (AttributeContainer) -> AttributeContainer

    public init(_ transform: @escaping (AttributeContainer) -> AttributeContainer)

    public func callAsFunction(_ input: AttributeContainer) -> AttributeContainer
}

@available(iOS 14.0, tvOS 14.0, *)
public protocol UIContentConfiguration {

    /// Initializes and returns a new instance of the content view using this configuration.
    func makeContentView() -> UIView & UIContentView

    /// Returns the configuration updated for the specified state, by applying the configuration's default values for that state to any properties that have not been customized.
    func updated(for state: UIConfigurationState) -> Self
}

@available(iOS 14.0, tvOS 14.0, *)
public protocol UIContentView : NSObjectProtocol {

    /// Returns the current configuration of the view. Setting this property applies the new configuration to the view.
    var configuration: UIContentConfiguration { get set }
}

@available(swift, deprecated: 4.2, message: "Use == operator instead.")
public func UIEdgeInsetsEqualToEdgeInsets(_ insets1: UIEdgeInsets, _ insets2: UIEdgeInsets) -> Bool

@available(swift, deprecated: 4.2, message: "Use == operator instead.")
public func UIFloatRangeIsEqualToRange(_ range: UIFloatRange, _ otherRange: UIFloatRange) -> Bool

@available(iOS 14.0, *)
open class UIIndirectScribbleInteraction<Delegate> : NSObject, UIInteraction where Delegate : UIIndirectScribbleInteractionDelegate {

    @objc weak public var view: UIView? { get }

    weak public var delegate: Delegate? { get }

    @objc public func willMove(to view: UIView?)

    @objc public func didMove(to view: UIView?)

    public init(delegate: Delegate)

    public var isHandlingWriting: Bool { get }
}

/**
 The protocol to be implemented by the delegate of UIIndirectScribbleInteraction. It will be responsible for supplying a list of writable elements, focusing them, and ultimately providing a real UITextInput that will handle text editing operations.
*/
@available(iOS 14.0, *)
public protocol UIIndirectScribbleInteractionDelegate : NSObjectProtocol {

    /**
     Element identifiers are used to identify writable elements in the interaction's view, and will be supplied in every delegate callback. Any type that conforms to Hashable and that can be compared for equality can be used. It is recommended to use simple immutable values, like strings, numbers, or UUIDs.
     */
    associatedtype ElementIdentifier : Hashable = String

    /**
     This method will be called to request the text input elements in a certain rect of the view, each of which represents an area where the user can start writing even if it's not a text input field itself.
     
     - Parameters:
        - interaction: The interaction asking for the elements.
        - rect: The rect around the area where the user is trying to write, in the interaction's view coordinate system. Only elements intersecting this rect should be returned.
        - completion: You must call the completion handler, synchronously or asynchronously, with an array of identifiers of the available elements, or an empty array if no elements are available.
     */
    func indirectScribbleInteraction(_ interaction: UIInteraction, requestElementsIn rect: CGRect, completion: @escaping ([Self.ElementIdentifier]) -> Void)

    /**
     This method will be called to request the text input elements in a certain rect of the view, each of which represents an area where the user can start writing even if it's not a text input field itself.
     
     - Parameters:
        - interaction: The interaction asking for the elements.
        - rect: The rect around the area where the user is trying to write, in the interaction's view coordinate system. Only elements intersecting this rect should be returned.
        - completion: You must call the completion handler, synchronously or asynchronously, with an array of identifiers of the available elements, or an empty array if no elements are available.
     
     - Note: If this method is implemented, ``indirectScribbleInteraction(_:requestElementsIn:completion:)`` will not be called.
     */
    @available(iOS 15.0, *)
    func indirectScribbleInteraction(_ interaction: UIInteraction, requestElementsIn rect: CGRect) async -> [Self.ElementIdentifier]

    /**
         Asks the delegate if an element is currently focused, according to the internal state of the interaction's view.
    
         - Parameters:
            - interaction: The interaction asking for the focused state.
            - elementIdentifier: The identifier of the element the interaction is asking about.
         
         - Returns: YES if the element is the one currently focused.
         */
    func indirectScribbleInteraction(_ interaction: UIInteraction, isElementFocused elementIdentifier: Self.ElementIdentifier) -> Bool

    /**
     Asks the delegate to provide the frame of an element.
     
     - Parameters:
        - interaction: The interaction asking for the element's frame.
        - elementIdentifier: The identifier of the element the interaction is asking about.
     
     - Returns: Frame for the element, in the interactions's view coordinate system.
     */
    func indirectScribbleInteraction(_ interaction: UIInteraction, frameForElement elementIdentifier: Self.ElementIdentifier) -> CGRect

    /**
     Asks the delegate to focus an element to handle text edits. In response, it should make the element the currently focused one, and make the corresponding UITextInput become first responder.
     
     If the element was not focused already, text selection should be set to the character location closest to focusReferencePoint, to avoid any scrolling or shifting of content.
     
     If the element was focused already, no changes in selection should be made and this call can be ignored, but you must still call the completion handler with a reference to the text input.
     
     - Parameters:
        - interaction The interaction that is requesting to focus an element.
        - elementIdentifier The identifier of the element that should be focused.
        @param completion You must always call the completion handler, either synchronously or asynchronously. On success, the first parameter should be the text input that became first responder and that will handle text operations for this element. On failure, call the completion with a nil parameter.
    */
    func indirectScribbleInteraction(_ interaction: UIInteraction, focusElementIfNeeded elementIdentifier: Self.ElementIdentifier, referencePoint focusReferencePoint: CGPoint, completion: @escaping ((UIResponder & UITextInput)?) -> Void)

    /**
     Asks the delegate to focus an element to handle text edits. In response, it should make the element the currently focused one, and make the corresponding UITextInput become first responder.
     
     If the element was not focused already, text selection should be set to the character location closest to focusReferencePoint, to avoid any scrolling or shifting of content.
     
     If the element was focused already, no changes in selection should be made and this call can be ignored, but you must still call the completion handler with a reference to the text input.
     
     - Parameters:
        - interaction The interaction that is requesting to focus an element.
        - elementIdentifier The identifier of the element that should be focused.
        @param completion You must always call the completion handler, either synchronously or asynchronously. On success, the first parameter should be the text input that became first responder and that will handle text operations for this element. On failure, call the completion with a nil parameter.
     
     - Note: If this method is implemented, ``indirectScribbleInteraction(_:focusElementIfNeeded:referencePoint:completion:)`` will not be called.
    */
    @available(iOS 15.0, *)
    func indirectScribbleInteraction(_ interaction: UIInteraction, focusElementIfNeeded elementIdentifier: Self.ElementIdentifier, referencePoint focusReferencePoint: CGPoint) async -> (UIResponder & UITextInput)?

    /**
     Allow the delegate to delay focusing an element. Normally, Scribble will focus the element as soon as the user begins writing, but if you return YES from this callback, it will wait until the user makes a brief pause. This is useful in cases where the element's frame will shift or transform when becoming focused, which can be disruptive to a user trying to handwrite into it.
     
     Wherever possible it is preferable to adjust the UI behavior to avoid the layout changes, and only use delayed focus as a last resort, since transcription will happen all at once instead of incrementally.
     
     - Parameters:
        - interaction: The interaction asking about delaying focus.
        - elementIdentifier: The identifier of the element the interaction is asking about.
     
     - Returns: YES to delay focusing the element.
     */
    func indirectScribbleInteraction(_ interaction: UIInteraction, shouldDelayFocusForElement elementIdentifier: Self.ElementIdentifier) -> Bool

    /**
     Will be called when the user begins writing into an element. This call will always be paired with a corresponding call to indirectScribbleInteraction:didFinishWritingInElement:. It is recommended to use this call to hide custom placeholders or other UI elements that can interfere with writing.
     
     - Parameters:
        - interaction: The interaction notifying about writing state changes.
        - elementIdentifier: The identifier of the element the user is writing into.
     */
    func indirectScribbleInteraction(_ interaction: UIInteraction, willBeginWritingInElement elementIdentifier: Self.ElementIdentifier)

    /**
     Will be called when the user finished writing into an element, after the last word has been transcribed and committed.
     
     - Parameters:
        - interaction: The interaction notifying about writing state changes.
        - elementIdentifier: The identifier of the element the user finished writing into.
    */
    func indirectScribbleInteraction(_ interaction: UIInteraction, didFinishWritingInElement elementIdentifier: Self.ElementIdentifier)
}

@available(iOS 14.0, *)
extension UIIndirectScribbleInteractionDelegate {

    /**
     Will be called when the user begins writing into an element. This call will always be paired with a corresponding call to indirectScribbleInteraction:didFinishWritingInElement:. It is recommended to use this call to hide custom placeholders or other UI elements that can interfere with writing.
     
     - Parameters:
        - interaction: The interaction notifying about writing state changes.
        - elementIdentifier: The identifier of the element the user is writing into.
     */
    public func indirectScribbleInteraction(_ interaction: UIInteraction, willBeginWritingInElement elementIdentifier: Self.ElementIdentifier)

    /**
     Will be called when the user finished writing into an element, after the last word has been transcribed and committed.
     
     - Parameters:
        - interaction: The interaction notifying about writing state changes.
        - elementIdentifier: The identifier of the element the user finished writing into.
    */
    public func indirectScribbleInteraction(_ interaction: UIInteraction, didFinishWritingInElement elementIdentifier: Self.ElementIdentifier)

    /**
     Allow the delegate to delay focusing an element. Normally, Scribble will focus the element as soon as the user begins writing, but if you return YES from this callback, it will wait until the user makes a brief pause. This is useful in cases where the element's frame will shift or transform when becoming focused, which can be disruptive to a user trying to handwrite into it.
     
     Wherever possible it is preferable to adjust the UI behavior to avoid the layout changes, and only use delayed focus as a last resort, since transcription will happen all at once instead of incrementally.
     
     - Parameters:
        - interaction: The interaction asking about delaying focus.
        - elementIdentifier: The identifier of the element the interaction is asking about.
     
     - Returns: YES to delay focusing the element.
     */
    public func indirectScribbleInteraction(_ interaction: UIInteraction, shouldDelayFocusForElement elementIdentifier: Self.ElementIdentifier) -> Bool
}

@available(iOS 15.0, *)
extension UIIndirectScribbleInteractionDelegate {

    /**
     This method will be called to request the text input elements in a certain rect of the view, each of which represents an area where the user can start writing even if it's not a text input field itself.
     
     - Parameters:
        - interaction: The interaction asking for the elements.
        - rect: The rect around the area where the user is trying to write, in the interaction's view coordinate system. Only elements intersecting this rect should be returned.
        - completion: You must call the completion handler, synchronously or asynchronously, with an array of identifiers of the available elements, or an empty array if no elements are available.
     
     - Note: If this method is implemented, ``indirectScribbleInteraction(_:requestElementsIn:completion:)`` will not be called.
     */
    public func indirectScribbleInteraction(_ interaction: UIInteraction, requestElementsIn rect: CGRect) async -> [Self.ElementIdentifier]

    /**
     Asks the delegate to focus an element to handle text edits. In response, it should make the element the currently focused one, and make the corresponding UITextInput become first responder.
     
     If the element was not focused already, text selection should be set to the character location closest to focusReferencePoint, to avoid any scrolling or shifting of content.
     
     If the element was focused already, no changes in selection should be made and this call can be ignored, but you must still call the completion handler with a reference to the text input.
     
     - Parameters:
        - interaction The interaction that is requesting to focus an element.
        - elementIdentifier The identifier of the element that should be focused.
        @param completion You must always call the completion handler, either synchronously or asynchronously. On success, the first parameter should be the text input that became first responder and that will handle text operations for this element. On failure, call the completion with a nil parameter.
     
     - Note: If this method is implemented, ``indirectScribbleInteraction(_:focusElementIfNeeded:referencePoint:completion:)`` will not be called.
    */
    public func indirectScribbleInteraction(_ interaction: UIInteraction, focusElementIfNeeded elementIdentifier: Self.ElementIdentifier, referencePoint focusReferencePoint: CGPoint) async -> (UIResponder & UITextInput)?
}

@available(iOS 14.0, tvOS 14.0, *)
public struct UIListContentConfiguration : UIContentConfiguration, Hashable {

    public struct ImageProperties : Hashable {

        /// The symbol configuration to use.
        public var preferredSymbolConfiguration: UIImage.SymbolConfiguration?

        /// The tintColor to apply to the image view. Nil will use the image view's
        /// normal inherited tintColor.
        public var tintColor: UIColor?

        /// Optional color transformer that is used to resolve the tint color. A nil value means
        /// the `tintColor` is used as-is.
        public var tintColorTransformer: UIConfigurationColorTransformer?

        /// Returns the resolved image tint color for the specified tint color of the view, based on
        /// the `tintColor` and `tintColorTransformer`.
        public func resolvedTintColor(for tintColor: UIColor) -> UIColor

        /// The preferred corner radius (using a continuous corner curve) for the image.
        /// Default is 0. If the image is too small to fit the requested radius, the corner curve
        /// and radius will be adjusted to fit.
        public var cornerRadius: CGFloat

        /// Enforces a maximum size for the image. The default value is CGSize.zero. A zero width or
        /// height means the size is unconstrained on that dimension. If the image exceeds this size
        /// on either dimension, its size will be reduced proportionately (maintaining aspect ratio).
        public var maximumSize: CGSize

        /// The layout size that is reserved for the image, inside which the image will be centered.
        /// The default value is CGSize.zero. The reservedLayoutSize width & height only affect the
        /// space reserved for the image and its positioning; it does not affect the image's size.
        /// A zero width or height means the default behavior is used for that dimension:
        ///     * Symbol images will be centered inside a predefined reservedLayoutSize that is
        ///       scaled with the content size category.
        ///     * Non-symbol images will use a reservedLayoutSize equal to the actual size of the
        ///       displayed image.
        /// This property is used for horizontal alignment of images across adjacent content views
        /// (even when the actual image widths may vary slightly), and/or to ensure the same height
        /// is reserved for different images across different content views (e.g. so the content view
        /// heights are consistent even when the actual image heights may vary slightly). The
        /// reservedLayoutSize.width is ignored by content views at Accessibility Dynamic Type
        /// sizes, and the reservedLayoutSize.height is ignored when using the special Accessibility
        /// Dynamic Type layout where text wraps around the image.
        public var reservedLayoutSize: CGSize

        /// Prevents the image from inverting its colors when the accessibility setting is enabled.
        public var accessibilityIgnoresInvertColors: Bool

        /// A special constant that can be set to the `reservedLayoutSize` width or height. This
        /// forces the system standard value that a symbol image would use for that dimension,
        /// even when the image is not a symbol image.
        public static let standardDimension: CGFloat

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: UIListContentConfiguration.ImageProperties, b: UIListContentConfiguration.ImageProperties) -> Bool

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }
    }

    public struct TextProperties : Hashable {

        public enum TextAlignment : Hashable {

            case natural

            case center

            case justified

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: UIListContentConfiguration.TextProperties.TextAlignment, b: UIListContentConfiguration.TextProperties.TextAlignment) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
            ///   compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            public var hashValue: Int { get }
        }

        public enum TextTransform : Hashable {

            case none

            case uppercase

            case lowercase

            case capitalized

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: UIListContentConfiguration.TextProperties.TextTransform, b: UIListContentConfiguration.TextProperties.TextTransform) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
            ///   compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            public var hashValue: Int { get }
        }

        /// The font used for the text.
        public var font: UIFont

        /// The color of the text.
        public var color: UIColor

        /// Optional color transformer that is used to resolve the color. A nil value means
        /// the `color` is used as-is.
        public var colorTransformer: UIConfigurationColorTransformer?

        /// Returns the resolved color, based on the `color` and `colorTransformer`.
        public func resolvedColor() -> UIColor

        /// The alignment for the text.
        public var alignment: UIListContentConfiguration.TextProperties.TextAlignment

        /// The line break mode to use for the text.
        public var lineBreakMode: NSLineBreakMode

        /// The maximum number of lines for the text. 0 indicates the number of lines is unlimited.
        public var numberOfLines: Int

        /// Whether the font size of the text is automatically adjusted when necessary to fit in the available width.
        public var adjustsFontSizeToFitWidth: Bool

        /// When `adjustsFontSizeToFitWidth` is enabled, the smallest multiplier for the font size used to make the text fit.
        public var minimumScaleFactor: CGFloat

        /// Whether the text is tightened before truncating.
        public var allowsDefaultTighteningForTruncation: Bool

        /// Whether the font is automatically updated when the content size category changes.
        public var adjustsFontForContentSizeCategory: Bool

        /// A transform that is applied to the text before it is displayed.
        public var transform: UIListContentConfiguration.TextProperties.TextTransform

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: UIListContentConfiguration.TextProperties, b: UIListContentConfiguration.TextProperties) -> Bool

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }
    }

    /// Returns the default configuration for a list cell.
    public static func cell() -> UIListContentConfiguration

    /// Returns the default configuration for a list cell with subtitle text.
    public static func subtitleCell() -> UIListContentConfiguration

    /// Returns the default configuration for a list cell with side-by-side value text.
    public static func valueCell() -> UIListContentConfiguration

    /// Returns the default configuration for a plain list header.
    public static func plainHeader() -> UIListContentConfiguration

    /// Returns the default configuration for a plain list footer.
    public static func plainFooter() -> UIListContentConfiguration

    /// Returns the default configuration for a grouped list header.
    public static func groupedHeader() -> UIListContentConfiguration

    /// Returns the default configuration for a grouped list footer.
    public static func groupedFooter() -> UIListContentConfiguration

    /// Returns the default configuration for a prominent inset grouped list header.
    @available(iOS 15.0, *)
    public static func prominentInsetGroupedHeader() -> UIListContentConfiguration

    /// Returns the default configuration for an extra prominent inset grouped list header.
    @available(iOS 15.0, *)
    public static func extraProminentInsetGroupedHeader() -> UIListContentConfiguration

    /// Returns the default configuration for a sidebar list cell.
    public static func sidebarCell() -> UIListContentConfiguration

    /// Returns the default configuration for a sidebar list cell with subtitle text.
    public static func sidebarSubtitleCell() -> UIListContentConfiguration

    /// Returns the default configuration for an accompanied sidebar list cell.
    public static func accompaniedSidebarCell() -> UIListContentConfiguration

    /// Returns the default configuration for an accompanied sidebar list cell with subtitle text.
    public static func accompaniedSidebarSubtitleCell() -> UIListContentConfiguration

    /// Returns the default configuration for a sidebar list header.
    public static func sidebarHeader() -> UIListContentConfiguration

    /// Initializes and returns a new instance of the content view using this configuration.
    public func makeContentView() -> UIView & UIContentView

    /// Returns the configuration updated for the specified state, by applying the configuration's default values for that state to any properties that have not been customized.
    public func updated(for state: UIConfigurationState) -> UIListContentConfiguration

    /// The image to display.
    public var image: UIImage?

    /// Additional properties to configure the image.
    public var imageProperties: UIListContentConfiguration.ImageProperties

    /// The primary text.
    public var text: String?

    /// An attributed variant of the primary text, which supersedes the `text` and some properties of the `textProperties` if set.
    public var attributedText: NSAttributedString?

    /// Additional properties to configure the primary text.
    public var textProperties: UIListContentConfiguration.TextProperties

    /// The secondary text.
    public var secondaryText: String?

    /// An attributed variant of the secondary text, which supersedes the `secondaryText` and some properties of the `secondaryTextProperties` if set.
    public var secondaryAttributedText: NSAttributedString?

    /// Additional properties to configure the secondary text.
    public var secondaryTextProperties: UIListContentConfiguration.TextProperties

    /// Whether the content view will preserve inherited layout margins from its superview on the horizontal and/or vertical axes.
    public var axesPreservingSuperviewLayoutMargins: UIAxis

    /// The margins for the content to the edges of the content view. (When preserving superview layout margins on one or both axes, these are just minimum margins, as inherited margins may be larger.)
    public var directionalLayoutMargins: NSDirectionalEdgeInsets

    /// When true, the text and secondary text will be positioned side-by-side if there is sufficient space. Otherwise, the text will be stacked in a vertical layout.
    public var prefersSideBySideTextAndSecondaryText: Bool

    /// Padding between the image and text. Only applies when there is both an image and text.
    public var imageToTextPadding: CGFloat

    /// Horizontal (minimum) padding between the text and secondary text. Only applies when there is both text and secondary text, and they are in a side-by-side layout.
    public var textToSecondaryTextHorizontalPadding: CGFloat

    /// Vertical padding between the text and secondary text. Only applies when there is both text and secondary text, and they are in a stacked layout.
    public var textToSecondaryTextVerticalPadding: CGFloat

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: UIListContentConfiguration, b: UIListContentConfiguration) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }
}

@available(iOS 14.0, tvOS 14.0, *)
extension UIListContentConfiguration : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@available(iOS 14.0, tvOS 14.0, *)
extension UIListContentConfiguration.ImageProperties : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@available(iOS 14.0, tvOS 14.0, *)
extension UIListContentConfiguration.TextProperties : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

/// This configuration allows for fine grained control of separator appearance in a UICollectionView List section.
/// See UICollectionLayoutListConfiguration.separatorConfiguration
@available(iOS 14.5, *)
@available(tvOS, unavailable)
public struct UIListSeparatorConfiguration : Hashable {

    public enum Visibility : Hashable {

        /// UICollectionView list sections will resolve this to an appropriate value.
        case automatic

        case visible

        case hidden

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: UIListSeparatorConfiguration.Visibility, b: UIListSeparatorConfiguration.Visibility) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }
    }

    /// The visibility of the top separator for the item that this configuration is applied to.
    public var topSeparatorVisibility: UIListSeparatorConfiguration.Visibility

    /// The visibility of the bottom separator for the item that this configuration is applied to.
    public var bottomSeparatorVisibility: UIListSeparatorConfiguration.Visibility

    /// Use the values from the edges in this constant to indicate to the consumer of a UIListSeparatorConfiguration that the value for that
    /// edge should be replaced with an appropriate inset.
    public static let automaticInsets: NSDirectionalEdgeInsets

    /// Insets to apply to the top separator of the item that this configuration is applied to. The top and bottom values are ignored.
    /// Defaults to \c UIListSeparatorConfiguration.automaticInsets
    public var topSeparatorInsets: NSDirectionalEdgeInsets

    /// Insets to apply to the bottom separator of the item that this configuration is applied to. The top and bottom values are ignored.
    /// Defaults to \c UIListSeparatorConfiguration.automaticInsets
    public var bottomSeparatorInsets: NSDirectionalEdgeInsets

    /// The color to use for the separators for the item this configuration is applied to.
    public var color: UIColor

    /// The color to use for the separators for the item this configuration is applied to, when the item is in a multiple selection group.
    public var multipleSelectionColor: UIColor

    /// The visual effect to apply to separators of the item this configuration is applied to.
    @available(iOS 15.0, *)
    @available(tvOS, unavailable)
    public var visualEffect: UIVisualEffect?

    /// Initializes a list separator configuration with the appropriate defaults for the passed in list appearance.
    /// - Parameter listAppearance: The appearance of the list consuming this separator configuration
    public init(listAppearance: UICollectionLayoutListConfiguration.Appearance)

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: UIListSeparatorConfiguration, b: UIListSeparatorConfiguration) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }
}

@available(iOS 14.5, *)
@available(tvOS, unavailable)
extension UIListSeparatorConfiguration : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@available(swift, deprecated: 4.2, message: "Use == operator instead.")
public func UIOffsetEqualToOffset(_ offset1: UIOffset, _ offset2: UIOffset) -> Bool

@available(iOS 13.4, *)
public enum UIPointerEffect {

    public enum TintMode {

        case none

        case overlay

        case underlay

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: UIPointerEffect.TintMode, b: UIPointerEffect.TintMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }
    }

    case automatic(UITargetedPreview)

    case highlight(UITargetedPreview)

    case lift(UITargetedPreview)

    case hover(UITargetedPreview, preferredTintMode: UIPointerEffect.TintMode = .overlay, prefersShadow: Bool = false, prefersScaledContent: Bool = true)

    public var preview: UITargetedPreview { get }
}

@available(iOS 13.4, *)
extension UIPointerEffect.TintMode : Equatable {
}

@available(iOS 13.4, *)
extension UIPointerEffect.TintMode : Hashable {
}

@available(iOS 13.4, *)
public enum UIPointerShape {

    case path(UIBezierPath)

    case roundedRect(CGRect, radius: CGFloat = UIPointerShape.defaultCornerRadius)

    case verticalBeam(length: CGFloat)

    case horizontalBeam(length: CGFloat)

    public static let defaultCornerRadius: CGFloat
}

@available(iOS 13.0, tvOS 13.0, *)
open class UITableViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType> : NSObject, UITableViewDataSource where SectionIdentifierType : Hashable, ItemIdentifierType : Hashable {

    public typealias CellProvider = (_ tableView: UITableView, _ indexPath: IndexPath, _ itemIdentifier: ItemIdentifierType) -> UITableViewCell?

    public init(tableView: UITableView, cellProvider: @escaping UITableViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.CellProvider)

    nonisolated open func apply(_ snapshot: NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, animatingDifferences: Bool = true, completion: (() -> Void)? = nil)

    @available(iOS 15.0, tvOS 15.0, *)
    nonisolated open func apply(_ snapshot: NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, animatingDifferences: Bool = true) async

    @available(iOS 15.0, tvOS 15.0, *)
    nonisolated open func applySnapshotUsingReloadData(_ snapshot: NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, completion: (() -> Void)? = nil)

    @available(iOS 15.0, tvOS 15.0, *)
    nonisolated open func applySnapshotUsingReloadData(_ snapshot: NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>) async

    nonisolated open func snapshot() -> NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>

    @available(iOS 15.0, tvOS 15.0, *)
    open func sectionIdentifier(for index: Int) -> SectionIdentifierType?

    @available(iOS 15.0, tvOS 15.0, *)
    open func index(for sectionIdentifier: SectionIdentifierType) -> Int?

    open func itemIdentifier(for indexPath: IndexPath) -> ItemIdentifierType?

    open func indexPath(for itemIdentifier: ItemIdentifierType) -> IndexPath?

    public var defaultRowAnimation: UITableView.RowAnimation

    @objc open func numberOfSections(in tableView: UITableView) -> Int

    @objc open func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int

    @objc open func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell

    @objc open func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -> String?

    @objc open func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -> String?

    @objc open func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool

    @objc open func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath)

    @objc open func tableView(_ tableView: UITableView, canMoveRowAt indexPath: IndexPath) -> Bool

    @objc open func tableView(_ tableView: UITableView, moveRowAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath)

    @objc open func sectionIndexTitles(for tableView: UITableView) -> [String]?

    @objc open func tableView(_ tableView: UITableView, sectionForSectionIndexTitle title: String, at index: Int) -> Int

    public func description() -> String
}

@available(iOS 14.0, tvOS 14.0, *)
public struct UIViewConfigurationState : UIConfigurationState, Hashable {

    public var traitCollection: UITraitCollection

    public var isDisabled: Bool

    public var isHighlighted: Bool

    public var isSelected: Bool

    public var isFocused: Bool

    @available(iOS 15.0, tvOS 15.0, *)
    public var isPinned: Bool

    /// Access custom states by key.
    public subscript(key: UIConfigurationStateCustomKey) -> AnyHashable?

    /// Returns a new instance with the specified trait collection.
    public init(traitCollection: UITraitCollection)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: UIViewConfigurationState, rhs: UIViewConfigurationState) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }
}

@available(iOS 14.0, tvOS 14.0, *)
extension UIViewConfigurationState : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@available(swift 5.1)
@available(iOS 15, tvOS 15, *)
public protocol UIViewInvalidating {

    func invalidate(view: UIView)
}

@available(swift 5.1)
@available(iOS 15, tvOS 15, *)
extension UIViewInvalidating where Self == UIView.Invalidations.Display {

    public static var display: UIView.Invalidations.Display { get }
}

@available(swift 5.1)
@available(iOS 15, tvOS 15, *)
extension UIViewInvalidating where Self == UIView.Invalidations.Layout {

    public static var layout: UIView.Invalidations.Layout { get }
}

@available(swift 5.1)
@available(iOS 15, tvOS 15, *)
extension UIViewInvalidating where Self == UIView.Invalidations.Constraints {

    public static var constraints: UIView.Invalidations.Constraints { get }
}

@available(swift 5.1)
@available(iOS 15, tvOS 15, *)
extension UIViewInvalidating where Self == UIView.Invalidations.IntrinsicContentSize {

    public static var intrinsicContentSize: UIView.Invalidations.IntrinsicContentSize { get }
}

@available(swift 5.1)
@available(iOS 15, tvOS 15, *)
extension UIViewInvalidating where Self == UIView.Invalidations.Configuration {

    public static var configuration: UIView.Invalidations.Configuration { get }
}

extension UIView {

    @available(swift 5.1)
    @available(iOS 15, tvOS 15, *)
    @propertyWrapper public struct Invalidating<Value, InvalidationType> where Value : Equatable, InvalidationType : UIViewInvalidating {

        public init(wrappedValue: Value, _ invalidation: InvalidationType)

        public init<InvalidationType1, InvalidationType2>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2) where InvalidationType == UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, InvalidationType1 : UIViewInvalidating, InvalidationType2 : UIViewInvalidating

        public init<InvalidationType1, InvalidationType2, InvalidationType3>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3) where InvalidationType == UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, InvalidationType3>, InvalidationType1 : UIViewInvalidating, InvalidationType2 : UIViewInvalidating, InvalidationType3 : UIViewInvalidating

        public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4) where InvalidationType == UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, UIView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, InvalidationType1 : UIViewInvalidating, InvalidationType2 : UIViewInvalidating, InvalidationType3 : UIViewInvalidating, InvalidationType4 : UIViewInvalidating

        public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5) where InvalidationType == UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, UIView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, InvalidationType5>, InvalidationType1 : UIViewInvalidating, InvalidationType2 : UIViewInvalidating, InvalidationType3 : UIViewInvalidating, InvalidationType4 : UIViewInvalidating, InvalidationType5 : UIViewInvalidating

        public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5, InvalidationType6>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5, _ invalidation6: InvalidationType6) where InvalidationType == UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, UIView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, UIView.Invalidations.Tuple<InvalidationType5, InvalidationType6>>, InvalidationType1 : UIViewInvalidating, InvalidationType2 : UIViewInvalidating, InvalidationType3 : UIViewInvalidating, InvalidationType4 : UIViewInvalidating, InvalidationType5 : UIViewInvalidating, InvalidationType6 : UIViewInvalidating

        public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5, InvalidationType6, InvalidationType7>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5, _ invalidation6: InvalidationType6, _ invalidation7: InvalidationType7) where InvalidationType == UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, UIView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType5, InvalidationType6>, InvalidationType7>>, InvalidationType1 : UIViewInvalidating, InvalidationType2 : UIViewInvalidating, InvalidationType3 : UIViewInvalidating, InvalidationType4 : UIViewInvalidating, InvalidationType5 : UIViewInvalidating, InvalidationType6 : UIViewInvalidating, InvalidationType7 : UIViewInvalidating

        public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5, InvalidationType6, InvalidationType7, InvalidationType8>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5, _ invalidation6: InvalidationType6, _ invalidation7: InvalidationType7, _ invalidation8: InvalidationType8) where InvalidationType == UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, UIView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType5, InvalidationType6>, UIView.Invalidations.Tuple<InvalidationType7, InvalidationType8>>>, InvalidationType1 : UIViewInvalidating, InvalidationType2 : UIViewInvalidating, InvalidationType3 : UIViewInvalidating, InvalidationType4 : UIViewInvalidating, InvalidationType5 : UIViewInvalidating, InvalidationType6 : UIViewInvalidating, InvalidationType7 : UIViewInvalidating, InvalidationType8 : UIViewInvalidating

        public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5, InvalidationType6, InvalidationType7, InvalidationType8, InvalidationType9>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5, _ invalidation6: InvalidationType6, _ invalidation7: InvalidationType7, _ invalidation8: InvalidationType8, _ invalidation9: InvalidationType9) where InvalidationType == UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, UIView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType5, InvalidationType6>, UIView.Invalidations.Tuple<InvalidationType7, InvalidationType8>>>, InvalidationType9>, InvalidationType1 : UIViewInvalidating, InvalidationType2 : UIViewInvalidating, InvalidationType3 : UIViewInvalidating, InvalidationType4 : UIViewInvalidating, InvalidationType5 : UIViewInvalidating, InvalidationType6 : UIViewInvalidating, InvalidationType7 : UIViewInvalidating, InvalidationType8 : UIViewInvalidating, InvalidationType9 : UIViewInvalidating

        public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5, InvalidationType6, InvalidationType7, InvalidationType8, InvalidationType9, InvalidationType10>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5, _ invalidation6: InvalidationType6, _ invalidation7: InvalidationType7, _ invalidation8: InvalidationType8, _ invalidation9: InvalidationType9, _ invalidation10: InvalidationType10) where InvalidationType == UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, UIView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType5, InvalidationType6>, UIView.Invalidations.Tuple<InvalidationType7, InvalidationType8>>>, UIView.Invalidations.Tuple<InvalidationType9, InvalidationType10>>, InvalidationType1 : UIViewInvalidating, InvalidationType2 : UIViewInvalidating, InvalidationType3 : UIViewInvalidating, InvalidationType4 : UIViewInvalidating, InvalidationType5 : UIViewInvalidating, InvalidationType6 : UIViewInvalidating, InvalidationType7 : UIViewInvalidating, InvalidationType8 : UIViewInvalidating, InvalidationType9 : UIViewInvalidating, InvalidationType10 : UIViewInvalidating
    }
}

extension UIView {

    @available(swift 5.1)
    @available(iOS 15, tvOS 15, *)
    public enum Invalidations {

        public struct Display : UIViewInvalidating {

            public init()

            public func invalidate(view: UIView)
        }

        public struct Layout : UIViewInvalidating {

            public init()

            public func invalidate(view: UIView)
        }

        public struct Constraints : UIViewInvalidating {

            public init()

            public func invalidate(view: UIView)
        }

        public struct IntrinsicContentSize : UIViewInvalidating {

            public init()

            public func invalidate(view: UIView)
        }

        public struct Configuration : UIViewInvalidating {

            public init()

            public func invalidate(view: UIView)
        }

        public struct Tuple<Invalidation1, Invalidation2> : UIViewInvalidating where Invalidation1 : UIViewInvalidating, Invalidation2 : UIViewInvalidating {

            public init(_ invalidation1: Invalidation1, _ invalidation2: Invalidation2)

            public func invalidate(view: UIView)
        }
    }
}

extension UIPasteboard {

    @available(iOS 15.0, *)
    public struct DetectedValues {

        public var patterns: Set<PartialKeyPath<UIPasteboard.DetectedValues>> { get }

        public var probableWebURL: String { get }

        public var probableWebSearch: String { get }

        public var number: Double? { get }

        public var links: [DDMatchLink] { get }

        public var phoneNumbers: [DDMatchPhoneNumber] { get }

        public var emailAddresses: [DDMatchEmailAddress] { get }

        public var postalAddresses: [DDMatchPostalAddress] { get }

        public var calendarEvents: [DDMatchCalendarEvent] { get }

        public var shipmentTrackingNumbers: [DDMatchShipmentTrackingNumber] { get }

        public var flightNumbers: [DDMatchFlightNumber] { get }

        public var moneyAmounts: [DDMatchMoneyAmount] { get }
    }
}

extension UIPasteboard {

    /// Detects patterns in the first pasteboard item.
    ///
    /// - Parameters:
    ///   - patterns: Detect only these patterns.
    ///   - completionHandler: Receives which patterns were detected, or an error.
    @available(iOS, introduced: 14.0, deprecated: 15.0)
    open func detectPatterns(for patterns: Set<UIPasteboard.DetectionPattern>, completionHandler: @escaping (Result<Set<UIPasteboard.DetectionPattern>, Error>) -> ())

    @available(iOS 15.0, *)
    open func detectPatterns(for keyPaths: Set<PartialKeyPath<UIPasteboard.DetectedValues>>, completionHandler: @escaping (Result<Set<PartialKeyPath<UIPasteboard.DetectedValues>>, Error>) -> ())

    @available(iOS 15.0, *)
    open func detectedPatterns(for keyPaths: Set<PartialKeyPath<UIPasteboard.DetectedValues>>) async throws -> Set<PartialKeyPath<UIPasteboard.DetectedValues>>

    /// Detects patterns in the specified pasteboard items.
    ///
    /// - Parameters:
    ///   - patterns: Detect only these patterns.
    ///   - itemSet: Specifies which pasteboard items by their position. Nil means all items.
    ///   - completionHandler: Receives which patterns were detected per item specified,
    ///                        or an error.
    @available(iOS, introduced: 14.0, deprecated: 15.0)
    open func detectPatterns(for patterns: Set<UIPasteboard.DetectionPattern>, inItemSet itemSet: IndexSet?, completionHandler: @escaping (Result<[Set<UIPasteboard.DetectionPattern>], Error>) -> ())

    @available(iOS 15.0, *)
    open func detectPatterns(for keyPaths: Set<PartialKeyPath<UIPasteboard.DetectedValues>>, inItemSet itemSet: IndexSet?, completionHandler: @escaping (Result<[Set<PartialKeyPath<UIPasteboard.DetectedValues>>], Error>) -> ())

    @available(iOS 15.0, *)
    open func detectedPatterns(for keyPaths: Set<PartialKeyPath<UIPasteboard.DetectedValues>>, inItemSet itemSet: IndexSet?) async throws -> [Set<PartialKeyPath<UIPasteboard.DetectedValues>>]

    /// Detects patterns and corresponding values in the first pasteboard item.
    ///
    /// - Parameters:
    ///   - patterns: Detect only these patterns.
    ///   - completionHandler: Receives which patterns and values were detected, or an error.
    @available(iOS, introduced: 14.0, deprecated: 15.0)
    open func detectValues(for patterns: Set<UIPasteboard.DetectionPattern>, completionHandler: @escaping (Result<[UIPasteboard.DetectionPattern : Any], Error>) -> ())

    @available(iOS 15.0, *)
    open func detectValues(for keyPaths: Set<PartialKeyPath<UIPasteboard.DetectedValues>>, completionHandler: @escaping (Result<UIPasteboard.DetectedValues, Error>) -> ())

    @available(iOS 15.0, *)
    open func detectedValues(for keyPaths: Set<PartialKeyPath<UIPasteboard.DetectedValues>>) async throws -> UIPasteboard.DetectedValues

    /// Detects patterns and corresponding values in the specified pasteboard items.
    ///
    /// - Parameters:
    ///   - patterns: Detect only these patterns.
    ///   - itemSet: Specifies which pasteboard items by their position. Nil means all items.
    ///   - completionHandler: Receives which patterns and values were detected per item specified,
    ///                        or an error.
    @available(iOS, introduced: 14.0, deprecated: 15.0)
    open func detectValues(for patterns: Set<UIPasteboard.DetectionPattern>, inItemSet itemSet: IndexSet?, completionHandler: @escaping (Result<[[UIPasteboard.DetectionPattern : Any]], Error>) -> ())

    @available(iOS 15.0, *)
    open func detectValues(for keyPaths: Set<PartialKeyPath<UIPasteboard.DetectedValues>>, inItemSet itemSet: IndexSet?, completionHandler: @escaping (Result<[UIPasteboard.DetectedValues], Error>) -> ())

    @available(iOS 15.0, *)
    open func detectedValues(for keyPaths: Set<PartialKeyPath<UIPasteboard.DetectedValues>>, inItemSet itemSet: IndexSet?) async throws -> [UIPasteboard.DetectedValues]
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewCell {

    @available(iOS 14.0, tvOS 14.0, *)
    public var contentConfiguration: UIContentConfiguration?
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewListCell {

    @available(iOS 14.0, tvOS 14.0, *)
    public func defaultContentConfiguration() -> UIListContentConfiguration
}

@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewCell {

    @available(iOS 14.0, tvOS 14.0, *)
    public var contentConfiguration: UIContentConfiguration?

    @available(iOS 14.0, tvOS 14.0, *)
    public func defaultContentConfiguration() -> UIListContentConfiguration
}

@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewHeaderFooterView {

    @available(iOS 14.0, tvOS 14.0, *)
    public var contentConfiguration: UIContentConfiguration?

    @available(iOS 14.0, tvOS 14.0, *)
    public func defaultContentConfiguration() -> UIListContentConfiguration
}

@available(iOS 14.0, tvOS 14.0, *)
extension UIListContentView : UIContentView {

    /// Returns the current configuration of the view. Setting this property applies the new configuration to the view.
    @available(iOS 14.0, tvOS 14.0, *)
    public var configuration: UIContentConfiguration

    @available(iOS 14.0, tvOS 14.0, *)
    public convenience init(configuration: UIListContentConfiguration)
}

@available(iOS 15.0, *)
extension UIPointerAccessory {

    public struct Position {

        public static let defaultOffset: CGFloat

        public var offset: CGFloat

        public var angle: CGFloat

        public init(offset: CGFloat = Position.defaultOffset, angle: CGFloat = 0)

        public static var top: UIPointerAccessory.Position { get }

        public static var topRight: UIPointerAccessory.Position { get }

        public static var right: UIPointerAccessory.Position { get }

        public static var bottomRight: UIPointerAccessory.Position { get }

        public static var bottom: UIPointerAccessory.Position { get }

        public static var bottomLeft: UIPointerAccessory.Position { get }

        public static var left: UIPointerAccessory.Position { get }

        public static var topLeft: UIPointerAccessory.Position { get }
    }

    public convenience init(_ shape: UIPointerShape, position: UIPointerAccessory.Position)

    public class func arrow(_ position: UIPointerAccessory.Position) -> Self

    public var shape: UIPointerShape { get }
}

@available(iOS 13.4, *)
extension UIPointerStyle {

    public convenience init(effect: UIPointerEffect, shape: UIPointerShape? = nil)

    public convenience init(shape: UIPointerShape, constrainedAxes: UIAxis = [])
}

@available(iOS 13.4, *)
extension UIPointerRegion {

    public convenience init(rect: CGRect, identifier: AnyHashable? = nil)

    public var identifier: AnyHashable? { get }
}

@available(iOS 13.4, *)
extension UIButton {

    public typealias PointerStyleProvider = (_ button: UIButton, _ proposedEffect: UIPointerEffect, _ proposedShape: UIPointerShape) -> UIPointerStyle?

    public var pointerStyleProvider: UIButton.PointerStyleProvider?
}

@available(iOS 15.0, *)
extension UIBandSelectionInteraction {

    public var selectionRect: CGRect? { get }
}

@available(iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes {

    public var uiKit: AttributeScopes.UIKitAttributes.Type { get }

    public struct UIKitAttributes : AttributeScope {

        public let font: AttributeScopes.UIKitAttributes.FontAttribute

        public let paragraphStyle: AttributeScopes.UIKitAttributes.ParagraphStyleAttribute

        public let foregroundColor: AttributeScopes.UIKitAttributes.ForegroundColorAttribute

        public let backgroundColor: AttributeScopes.UIKitAttributes.BackgroundColorAttribute

        public let ligature: AttributeScopes.UIKitAttributes.LigatureAttribute

        public let kern: AttributeScopes.UIKitAttributes.KernAttribute

        public let tracking: AttributeScopes.UIKitAttributes.TrackingAttribute

        public let strikethroughStyle: AttributeScopes.UIKitAttributes.StrikethroughStyleAttribute

        public let underlineStyle: AttributeScopes.UIKitAttributes.UnderlineStyleAttribute

        public let strokeColor: AttributeScopes.UIKitAttributes.StrokeColorAttribute

        public let strokeWidth: AttributeScopes.UIKitAttributes.StrokeWidthAttribute

        public let shadow: AttributeScopes.UIKitAttributes.ShadowAttribute

        public let textEffect: AttributeScopes.UIKitAttributes.TextEffectAttribute

        public let baselineOffset: AttributeScopes.UIKitAttributes.BaselineOffsetAttribute

        public let underlineColor: AttributeScopes.UIKitAttributes.UnderlineColorAttribute

        public let strikethroughColor: AttributeScopes.UIKitAttributes.StrikethroughColorAttribute

        public let obliqueness: AttributeScopes.UIKitAttributes.ObliquenessAttribute

        public let expansion: AttributeScopes.UIKitAttributes.ExpansionAttribute

        @available(watchOS, unavailable)
        public let attachment: AttributeScopes.UIKitAttributes.AttachmentAttribute

        public let accessibility: AttributeScopes.AccessibilityAttributes

        public let foundation: AttributeScopes.FoundationAttributes

        public typealias DecodingConfiguration = AttributeScopeCodableConfiguration

        public typealias EncodingConfiguration = AttributeScopeCodableConfiguration
    }
}

@available(iOS 15, tvOS 15, watchOS 8, *)
extension AttributeDynamicLookup {

    public subscript<T>(dynamicMember keyPath: KeyPath<AttributeScopes.UIKitAttributes, T>) -> T where T : AttributedStringKey { get }
}

@available(iOS 15, tvOS 15, watchOS 8, *)
extension NSUnderlineStyle : Hashable {
}

@available(iOS 15.0, *)
extension UISheetPresentationController {

    /// The preferred corner radius of the sheet when presented.
    /// This value is only respected when the sheet is at the front of its stack.
    /// Default: nil
    @available(iOS 15.0, *)
    public var preferredCornerRadius: CGFloat?
}

extension UIBarButtonItem {

    @available(iOS 14.0, *)
    public convenience init(systemItem: UIBarButtonItem.SystemItem, primaryAction: UIAction? = nil, menu: UIMenu? = nil)

    @available(iOS 14.0, *)
    public convenience init(title: String? = nil, image: UIImage? = nil, primaryAction: UIAction? = nil, menu: UIMenu? = nil)
}

extension UIControl {

    @available(iOS 14.0, *)
    public func enumerateEventHandlers(_ iterator: (UIAction?, (Any?, Selector)?, UIControl.Event, inout Bool) -> Void)
}

extension UIButton {

    @available(iOS 14.0, *)
    public convenience init(type buttonType: UIButton.ButtonType = .system, primaryAction: UIAction?)
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewCell {

    @available(iOS 14.0, tvOS 14.0, *)
    public var backgroundConfiguration: UIBackgroundConfiguration?
}

@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewCell {

    @available(iOS 14.0, tvOS 14.0, *)
    public var backgroundConfiguration: UIBackgroundConfiguration?
}

@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewHeaderFooterView {

    @available(iOS 14.0, tvOS 14.0, *)
    public var backgroundConfiguration: UIBackgroundConfiguration?
}

@available(iOS 15.0, *)
@available(tvOS, unavailable)
extension UIToolTipConfiguration {

    public var sourceRect: CGRect? { get }
}

extension UIEdgeInsets : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: UIEdgeInsets, rhs: UIEdgeInsets) -> Bool
}

@available(iOS 11.0, tvOS 11.0, watchOS 4.0, *)
extension NSDirectionalEdgeInsets : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: NSDirectionalEdgeInsets, rhs: NSDirectionalEdgeInsets) -> Bool
}

extension UIOffset : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: UIOffset, rhs: UIOffset) -> Bool
}

extension UIFloatRange : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: UIFloatRange, rhs: UIFloatRange) -> Bool
}

extension UIEdgeInsets : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

@available(iOS 11.0, tvOS 11.0, watchOS 4.0, *)
extension NSDirectionalEdgeInsets : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension UIOffset : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension UIFloatRange : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension UIActionSheet {

    public convenience init(title: String?, delegate: UIActionSheetDelegate?, cancelButtonTitle: String?, destructiveButtonTitle: String?, otherButtonTitles firstButtonTitle: String, _ moreButtonTitles: String...)
}

extension UIAlertView {

    public convenience init(title: String, message: String, delegate: UIAlertViewDelegate?, cancelButtonTitle: String?, otherButtonTitles firstButtonTitle: String, _ moreButtonTitles: String...)
}

extension UIImage {

    /// Creates an instance initialized with the given resource name.
    ///
    /// Do not call this initializer directly. Instead, initialize a variable or
    /// constant using an image literal.
    required public convenience init(imageLiteralResourceName name: String)
}

extension UIFont.TextStyle {

    @available(iOS 11.0, watchOS 4.0, tvOS 11.0, *)
    public var metrics: UIFontMetrics { get }
}

extension UIContentSizeCategory {

    @available(iOS 11.0, tvOS 11.0, *)
    public var isAccessibilityCategory: Bool { get }

    @available(iOS 11.0, tvOS 11.0, *)
    public static func < (left: UIContentSizeCategory, right: UIContentSizeCategory) -> Bool

    @available(iOS 11.0, tvOS 11.0, *)
    public static func <= (left: UIContentSizeCategory, right: UIContentSizeCategory) -> Bool

    @available(iOS 11.0, tvOS 11.0, *)
    public static func > (left: UIContentSizeCategory, right: UIContentSizeCategory) -> Bool

    @available(iOS 11.0, tvOS 11.0, *)
    public static func >= (left: UIContentSizeCategory, right: UIContentSizeCategory) -> Bool
}

@available(iOS 11.0, tvOS 11.0, *)
extension UIFocusEnvironment {

    @available(iOS 11.0, tvOS 11.0, *)
    public func contains(_ environment: UIFocusEnvironment) -> Bool
}

@available(iOS 11.0, tvOS 11.0, *)
extension UIFocusItem {

    @available(iOS 11.0, tvOS 11.0, *)
    public var isFocused: Bool { get }
}

@available(iOS 11.0, *)
extension UIDragDropSession {

    @available(iOS 11.0, *)
    public func canLoadObjects<T>(ofClass: T.Type) -> Bool where T : _ObjectiveCBridgeable, T._ObjectiveCType : NSItemProviderReading
}

@available(iOS 11.0, *)
extension UIDropSession {

    @available(iOS 11.0, *)
    public func loadObjects<T>(ofClass: T.Type, completion: @escaping ([T]) -> Void) -> Progress where T : _ObjectiveCBridgeable, T._ObjectiveCType : NSItemProviderReading
}

@available(iOS 11.0, *)
extension UIPasteConfiguration {

    @available(iOS 11.0, *)
    public convenience init<T>(forAccepting _: T.Type) where T : _ObjectiveCBridgeable, T._ObjectiveCType : NSItemProviderReading

    @available(iOS 11.0, *)
    public func addTypeIdentifiers<T>(forAccepting aClass: T.Type) where T : _ObjectiveCBridgeable, T._ObjectiveCType : NSItemProviderReading
}

extension UIPasteboard {

    @available(iOS 11.0, *)
    public func setObjects<T>(_ objects: [T]) where T : _ObjectiveCBridgeable, T._ObjectiveCType : NSItemProviderWriting

    @available(iOS 11.0, *)
    public func setObjects<T>(_ objects: [T], localOnly: Bool, expirationDate: Date?) where T : _ObjectiveCBridgeable, T._ObjectiveCType : NSItemProviderWriting
}

extension UIApplicationDelegate {

    public static func main()
}

extension UIStoryboard {

    @available(iOS 13.0, tvOS 13.0, *)
    public func instantiateInitialViewController<ViewController>(creator: ((NSCoder) -> ViewController?)? = nil) -> ViewController? where ViewController : UIViewController

    @available(iOS 13.0, tvOS 13.0, *)
    public func instantiateViewController<ViewController>(identifier: String, creator: ((NSCoder) -> ViewController?)? = nil) -> ViewController where ViewController : UIViewController
}

extension UIAccessibilityTraits : OptionSet {

    /// The type of the elements of an array literal.
    public typealias ArrayLiteralElement = UIAccessibilityTraits

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    public typealias Element = UIAccessibilityTraits
}

extension UITextDirection {

    public static func storage(_ direction: UITextStorageDirection) -> UITextDirection

    public static func layout(_ direction: UITextLayoutDirection) -> UITextDirection
}

@available(iOS 13.0, *)
extension UICommand {

    /// Initializes a keyless command with extra properties.
    ///
    /// - Parameters:
    ///   - title: Short display title. This should be localized.
    ///   - image: Image that can appear next to the command, if any.
    ///   - action: Action to execute on choosing this command.
    ///   - propertyList: Property list object to distinguish commands, if needed.
    ///   - alternates: Alternates that differ in modifier flags, if needed.
    ///   - discoverabilityTitle: Elaborated title, if any.
    ///   - attributes: Command attributes.
    ///   - state: State that can appear next to the command.
    public convenience init(title: String = "", image: UIImage? = nil, action: Selector, propertyList: Any? = nil, alternates: [UICommandAlternate] = [], discoverabilityTitle: String? = nil, attributes: UIMenuElement.Attributes = [], state: UIMenuElement.State = .off)

    @available(iOS 15.0, tvOS 15.0, *)
    public convenience init(title: String = "", subtitle: String? = nil, image: UIImage? = nil, action: Selector, propertyList: Any? = nil, alternates: [UICommandAlternate] = [], discoverabilityTitle: String? = nil, attributes: UIMenuElement.Attributes = [], state: UIMenuElement.State = .off)
}

@available(iOS 13.0, *)
extension UIKeyCommand {

    /// Initializes a key command with extra properties.
    ///
    /// - Parameters:
    ///   - title: Short display title. This should be localized.
    ///   - action: Action to execute on choosing this command.
    ///   - input: Keys that must be pressed to choose this command.
    ///   - modifierFlags: Bit mask of key modifier flags to choose this command.
    ///   - propertyList: Property list object to distinguish commands, if needed.
    ///   - alternates: Alternates that differ in modifier flags, if needed.
    ///   - image: Image that can appear next to the command, if any.
    ///   - discoverabilityTitle: Elaborated title, if any.
    ///   - isEnabled: Whether to enable or disable the command.
    ///   - state: State that can appear next to the command.
    public convenience init(title: String = "", image: UIImage? = nil, action: Selector, input: String, modifierFlags: UIKeyModifierFlags = [], propertyList: Any? = nil, alternates: [UICommandAlternate] = [], discoverabilityTitle: String? = nil, attributes: UIMenuElement.Attributes = [], state: UIMenuElement.State = .off)
}

@available(iOS 13.0, tvOS 14.0, *)
extension UIAction {

    /// Creates a UIAction with the given arguments.
    ///
    /// - Parameters:
    ///   - title: The action's title.
    ///   - image: Image to be displayed alongside the action's title.
    ///   - identifier: Action's unique identifier. Pass nil to use an auto-generated identifier.
    ///   - discoverabilityTitle: Elaborated title, if any.
    ///   - attributes: Action's attributes.
    ///   - state: State that can appear next to the action.
    ///   - handler: Handler block. Called when the user selects the action.
    public convenience init(title: String = "", image: UIImage? = nil, identifier: UIAction.Identifier? = nil, discoverabilityTitle: String? = nil, attributes: UIMenuElement.Attributes = [], state: UIMenuElement.State = .off, handler: @escaping UIActionHandler)

    @available(iOS 15.0, tvOS 15.0, *)
    public convenience init(title: String = "", subtitle: String? = nil, image: UIImage? = nil, identifier: UIAction.Identifier? = nil, discoverabilityTitle: String? = nil, attributes: UIMenuElement.Attributes = [], state: UIMenuElement.State = .off, handler: @escaping UIActionHandler)
}

@available(iOS 13.0, tvOS 14.0, *)
extension UIMenu {

    /// Creates a UIMenu with the given arguments.
    ///
    /// - Parameters:
    ///   - title: The menu's title.
    ///   - image: Image to be displayed alongside the menu's title.
    ///   - identifier: The menu's unique identifier. Pass nil to use an auto-generated identifier.
    ///   - options: The menu's options.
    ///   - children: The menu's sub-elements and sub-menus.
    public convenience init(title: String = "", image: UIImage? = nil, identifier: UIMenu.Identifier? = nil, options: UIMenu.Options = [], children: [UIMenuElement] = [])

    @available(iOS 15.0, tvOS 15.0, *)
    public convenience init(title: String = "", subtitle: String? = nil, image: UIImage? = nil, identifier: UIMenu.Identifier? = nil, options: UIMenu.Options = [], children: [UIMenuElement] = [])
}

@available(iOS 13.0, tvOS 14.0, *)
extension UIMenuBuilder {

    /// Fetch the identified command.
    ///
    /// - Parameters:
    ///   - action: The action of the command to find.
    ///   - propertyList: Property list object to distinguish commands, if needed.
    /// - Returns: The command with the given action and property list, or `nil` if no such command.
    public func command(for action: Selector, propertyList: Any? = nil) -> UICommand?
}

@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension UIImage {

    public var baselineOffsetFromBottom: CGFloat? { get }
}

@available(iOS 15.0, *)
extension UIWindowScene.ActivationConfiguration {

    /// Creates a new `ActivationConfiguration`.
    ///
    /// - Parameters:
    ///     - userActivity: The user activity that will be used to request a scene.
    ///     - options: Options for customizing the scene request. Specify `nil` to use the default options.
    ///     - preview: An optional preview used to define the visual "source" of the newly activated scene for use in system animations.
    public convenience init(userActivity: NSUserActivity, options: UIWindowScene.ActivationRequestOptions? = nil, preview: UITargetedPreview? = nil)
}

@available(iOS 15.0, *)
extension UIWindowScene.ActivationAction {

    /// Creates a new `ActivationAction`.
    ///
    /// - Parameters:
    ///     - title: The title to display for the action. Specify `nil` to use the default title.
    ///     - image: The image to display next to the action's title. Specify `nil` to use the default image.
    ///     - identifier: The unique identifier for the action.
    ///     - discoverabilityTitle: An elaborated title that explains the purpose of the action.
    ///     - attributes: The attributes indicating the style of the action.
    ///     - alternate: An alternate action to perform if the platform does not support multiple scenes or if requesting a scene fails.
    ///     - configuration: A closure called to provide a `UIWindowScene.ActivationConfiguration` when action is invoked.
    public convenience init(title: String? = nil, subtitle: String? = nil, image: UIImage? = nil, identifier: UIAction.Identifier? = nil, discoverabilityTitle: String? = nil, attributes: UIMenuElement.Attributes = [], alternate: UIAction? = nil, _ configuration: @escaping UIWindowScene.ActivationAction.ConfigurationProvider)
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionView {

    public struct CellRegistration<Cell, Item> where Cell : UICollectionViewCell {

        public typealias Handler = (_ cell: Cell, _ indexPath: IndexPath, _ itemIdentifier: Item) -> Void

        public init(handler: @escaping UICollectionView.CellRegistration<Cell, Item>.Handler)

        public init(cellNib: UINib, handler: @escaping UICollectionView.CellRegistration<Cell, Item>.Handler)
    }

    public struct SupplementaryRegistration<Supplementary> where Supplementary : UICollectionReusableView {

        public typealias Handler = (_ supplementaryView: Supplementary, _ elementKind: String, _ indexPath: IndexPath) -> Void

        public init(elementKind: String, handler: @escaping UICollectionView.SupplementaryRegistration<Supplementary>.Handler)

        public init(supplementaryNib: UINib, elementKind: String, handler: @escaping UICollectionView.SupplementaryRegistration<Supplementary>.Handler)
    }

    public func dequeueConfiguredReusableCell<Cell, Item>(using registration: UICollectionView.CellRegistration<Cell, Item>, for indexPath: IndexPath, item: Item?) -> Cell where Cell : UICollectionViewCell

    public func dequeueConfiguredReusableSupplementary<Supplementary>(using registration: UICollectionView.SupplementaryRegistration<Supplementary>, for indexPath: IndexPath) -> Supplementary where Supplementary : UICollectionReusableView
}

@available(iOS 15.0, tvOS 15.0, *)
extension UIButton {

    public struct Configuration : Hashable {

        public enum Size {

            case mini

            case small

            case medium

            case large

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: UIButton.Configuration.Size, b: UIButton.Configuration.Size) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
            ///   compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            public var hashValue: Int { get }
        }

        public enum TitleAlignment {

            /// Align title & subtitle automatically
            case automatic

            /// Align title & subtitle along their leading edges
            case leading

            /// Align title & subtitle to be centered with respect to each other
            case center

            /// Align title & subtitle along their trailing edges
            case trailing

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: UIButton.Configuration.TitleAlignment, b: UIButton.Configuration.TitleAlignment) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
            ///   compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            public var hashValue: Int { get }
        }

        public enum CornerStyle {

            /// The corner radius provided by the background style will be used as is, without adjusting for dynamic type
            case fixed

            /// The corner radius provided by the background style is adjusted based on dynamic type
            case dynamic

            /// Ignore the corner radius provided by the background style and substitute a small system defined corner radius.
            case small

            /// Ignore the corner radius provided by the background style and substitute a medium system defined corner radius.
            case medium

            /// Ignore the corner radius provided by the background style and substitute a large system defined corner radius.
            case large

            /// Ignore the corner radius provided by the background style and always set the corner radius to generate a capsule.
            case capsule

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: UIButton.Configuration.CornerStyle, b: UIButton.Configuration.CornerStyle) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
            ///   compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            public var hashValue: Int { get }
        }

        public enum MacIdiomStyle {

            /// Automatically select the style to use
            case automatic

            /// Always use a bordered style button
            case bordered

            /// Always use a borderless style button
            case borderless

            /// Always use a tinted, borderless style button
            case borderlessTinted

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: UIButton.Configuration.MacIdiomStyle, b: UIButton.Configuration.MacIdiomStyle) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
            ///   compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            public var hashValue: Int { get }
        }

        public static func plain() -> UIButton.Configuration

        public static func tinted() -> UIButton.Configuration

        public static func gray() -> UIButton.Configuration

        public static func filled() -> UIButton.Configuration

        public static func borderless() -> UIButton.Configuration

        public static func bordered() -> UIButton.Configuration

        public static func borderedTinted() -> UIButton.Configuration

        public static func borderedProminent() -> UIButton.Configuration

        /// Returns a copy of the configuration updated based on the given button, by applying the configuration's default values for that button's state to any properties that have not been customized.
        public func updated(for button: UIButton) -> UIButton.Configuration

        public var background: UIBackgroundConfiguration

        /// The corner style controls how background.cornerRadius is interpreted by the button. Defaults to `.dynamic`.
        public var cornerStyle: UIButton.Configuration.CornerStyle

        /// Determines the metrics and ideal size of the button. Clients may resize the button arbitrarily regardless of this value.
        public var buttonSize: UIButton.Configuration.Size

        /// Button style to use when running under the Mac idiom.
        public var macIdiomStyle: UIButton.Configuration.MacIdiomStyle

        /// The base color to use for foreground elements. This color may be modified before being passed to a transformer, and finally applied to specific elements. Setting nil will cede full control to the configuration to select a color appropriate to the style.
        public var baseForegroundColor: UIColor?

        /// The base color to use for background elements. This color may be modified before being passed to a transformer, and finally applied to specific elements. Setting nil will cede full control to the configuration to select a color appropriate to the style.
        public var baseBackgroundColor: UIColor?

        public var image: UIImage?

        public var imageColorTransformer: UIConfigurationColorTransformer?

        public var preferredSymbolConfigurationForImage: UIImage.SymbolConfiguration?

        /// Shows an activity indicator in place of an image. Its placement is controlled by the imagePlacement property.
        public var showsActivityIndicator: Bool

        public var activityIndicatorColorTransformer: UIConfigurationColorTransformer?

        public var title: String?

        public var attributedTitle: AttributedString?

        public var titleTextAttributesTransformer: UIConfigurationTextAttributesTransformer?

        public var subtitle: String?

        public var attributedSubtitle: AttributedString?

        public var subtitleTextAttributesTransformer: UIConfigurationTextAttributesTransformer?

        /// By default the button's content region is inset from its bounds based on the button's styling properties. The contentInsets are an additional inset applied afterwards.
        public var contentInsets: NSDirectionalEdgeInsets

        /// Restore the default content insets.
        public mutating func setDefaultContentInsets()

        /// Defaults to Leading, only single edge values (top/leading/bottom/trailing) are supported.
        public var imagePlacement: NSDirectionalRectEdge

        /// When a button has both image and text content, this value is the padding between the image and the text.
        public var imagePadding: CGFloat

        /// When a button has both a title & subtitle, this value is the padding between those titles.
        public var titlePadding: CGFloat

        /// The alignment to use for relative layout between title & subtitle.
        public var titleAlignment: UIButton.Configuration.TitleAlignment

        /// If the style should automatically update when the button is selected. Default varies by style. Disable to customize selection behavior.
        public var automaticallyUpdateForSelection: Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: UIButton.Configuration, b: UIButton.Configuration) -> Bool

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }
    }

    public convenience init(configuration: UIButton.Configuration, primaryAction: UIAction? = nil)

    public var configuration: UIButton.Configuration?
}

extension UIViewController {

    @available(iOS 15.0, tvOS 15.0, *)
    public func setContentScrollView(_ scrollView: UIScrollView?)
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewListCell {

    @available(iOS 14.0, tvOS 14.0, *)
    public var accessories: [UICellAccessory]
}

@available(iOS 15.0, tvOS 15.0, *)
extension UIFocusSystem {

    public class func focusSystem(for environment: UIFocusEnvironment) -> UIFocusSystem?
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewCompositionalLayout {

    public static func list(using configuration: UICollectionLayoutListConfiguration) -> UICollectionViewCompositionalLayout
}

@available(iOS 14.0, tvOS 14.0, *)
extension NSCollectionLayoutSection {

    public static func list(using configuration: UICollectionLayoutListConfiguration, layoutEnvironment: NSCollectionLayoutEnvironment) -> NSCollectionLayoutSection
}

extension IndexPath {

    /// Initialize for use with `UITableView` or `UICollectionView`.
    public init(row: Int, section: Int)

    /// Initialize for use with `UITableView` or `UICollectionView`.
    public init(item: Int, section: Int)

    /// The section of this index path, when used with `UITableView` or `UICollectionView`.
    ///
    /// - precondition: The index path must have at least one element.
    public var section: Int

    /// The row of this index path, when used with `UITableView`.
    ///
    /// - precondition: The index path must have exactly two elements.
    public var row: Int

    /// The item of this index path, when used with `UICollectionView`.
    ///
    /// - precondition: The index path must have at least one element (to get), or exactly two elements (to set).
    public var item: Int
}

extension URLResourceValues {

    /// Returns a dictionary of UIImage objects keyed by size.
    @available(iOS 8.0, *)
    public var thumbnailDictionary: [URLThumbnailDictionaryItem : UIImage]? { get }
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewCell {

    /// Returns the current configuration state for the cell.
    /// To add your own custom state(s), override the getter and call super to obtain a struct with the
    /// system properties set, then set your own custom states as desired.
    @available(iOS 14.0, tvOS 14.0, *)
    @objc(_bridgedConfigurationState) dynamic open var configurationState: UICellConfigurationState { get }

    /// Subclasses should override this method and update the cell's configuration using the state provided.
    /// This method should not be called directly, use `setNeedsUpdateConfiguration` to request an update.
    @available(iOS 14.0, tvOS 14.0, *)
    @objc(_bridgedUpdateConfigurationUsingState:) dynamic open func updateConfiguration(using state: UICellConfigurationState)

    @available(iOS 15.0, tvOS 15.0, *)
    public typealias ConfigurationUpdateHandler = (_ cell: UICollectionViewCell, _ state: UICellConfigurationState) -> Void

    /// Optional closure-based alternative to overriding `updateConfiguration(using:)` in a subclass. This handler
    /// is called after `updateConfiguration(using:)`. Setting a new handler triggers `setNeedsUpdateConfiguration`.
    @available(iOS 15.0, tvOS 15.0, *)
    public var configurationUpdateHandler: UICollectionViewCell.ConfigurationUpdateHandler?
}

@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewCell {

    /// Returns the current configuration state for the cell.
    /// To add your own custom state(s), override the getter and call super to obtain a struct with the
    /// system properties set, then set your own custom states as desired.
    @available(iOS 14.0, tvOS 14.0, *)
    @objc(_bridgedConfigurationState) dynamic open var configurationState: UICellConfigurationState { get }

    /// Subclasses should override this method and update the cell's configuration using the state provided.
    /// This method should not be called directly, use `setNeedsUpdateConfiguration` to request an update.
    @available(iOS 14.0, tvOS 14.0, *)
    @objc(_bridgedUpdateConfigurationUsingState:) dynamic open func updateConfiguration(using state: UICellConfigurationState)

    @available(iOS 15.0, tvOS 15.0, *)
    public typealias ConfigurationUpdateHandler = (_ cell: UITableViewCell, _ state: UICellConfigurationState) -> Void

    /// Optional closure-based alternative to overriding `updateConfiguration(using:)` in a subclass. This handler
    /// is called after `updateConfiguration(using:)`. Setting a new handler triggers `setNeedsUpdateConfiguration`.
    @available(iOS 15.0, tvOS 15.0, *)
    public var configurationUpdateHandler: UITableViewCell.ConfigurationUpdateHandler?
}

@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewHeaderFooterView {

    /// Returns the current configuration state for the header/footer.
    /// To add your own custom state(s), override the getter and call super to obtain a struct with the
    /// system properties set, then set your own custom states as desired.
    @available(iOS 14.0, tvOS 14.0, *)
    @objc(_bridgedConfigurationState) dynamic open var configurationState: UIViewConfigurationState { get }

    /// Subclasses should override this method and update the view's configuration using the state provided.
    /// This method should not be called directly, use `setNeedsUpdateConfiguration` to request an update.
    @available(iOS 14.0, tvOS 14.0, *)
    @objc(_bridgedUpdateConfigurationUsingState:) dynamic open func updateConfiguration(using state: UIViewConfigurationState)

    @available(iOS 15.0, tvOS 15.0, *)
    public typealias ConfigurationUpdateHandler = (_ headerFooterView: UITableViewHeaderFooterView, _ state: UIViewConfigurationState) -> Void

    /// Optional closure-based alternative to overriding `updateConfiguration(using:)` in a subclass. This handler
    /// is called after `updateConfiguration(using:)`. Setting a new handler triggers `setNeedsUpdateConfiguration`.
    @available(iOS 15.0, tvOS 15.0, *)
    public var configurationUpdateHandler: UITableViewHeaderFooterView.ConfigurationUpdateHandler?
}

